<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Hungry Cookie - „Éè„É≥„Ç∞„É™„Éº„ÇØ„ÉÉ„Ç≠„Éº</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Nunito', sans-serif;
    background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 50%, #a5d6a7 100%);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    overflow: hidden;
    touch-action: none;
  }

  .game-wrapper {
    width: 100%;
    max-width: 420px;
    background: #fff9f0;
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.15);
    padding: 16px;
    position: relative;
    overflow: hidden;
  }

  .game-wrapper::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 5px;
    background: linear-gradient(90deg, #66bb6a, #ffa726, #ab47bc, #42a5f5);
  }

  .game-header {
    text-align: center;
    margin-bottom: 10px;
  }

  .game-header h1 {
    font-size: 1.4rem;
    font-weight: 900;
    color: #2e7d32;
  }

  .game-header .sub {
    font-size: 0.7rem;
    color: #81c784;
  }

  .hud {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-size: 0.8rem;
    font-weight: 700;
    color: #4e342e;
  }

  .hud-left, .hud-right {
    display: flex;
    gap: 12px;
    align-items: center;
  }

  .hp-bar-container {
    width: 80px;
    height: 12px;
    background: #e0e0e0;
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #bdbdbd;
  }

  .hp-bar {
    height: 100%;
    background: linear-gradient(90deg, #66bb6a, #43a047);
    transition: width 0.3s ease;
    border-radius: 6px;
  }

  .hp-bar.danger {
    background: linear-gradient(90deg, #ef5350, #e53935);
  }

  .hp-bar.warning {
    background: linear-gradient(90deg, #ffa726, #fb8c00);
  }

  canvas {
    display: block;
    width: 100%;
    border-radius: 12px;
    border: 2px solid #a5d6a7;
    background: #f1f8e9;
    touch-action: none;
  }

  .screen-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.6);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 20px;
    z-index: 10;
  }

  .screen-overlay.hidden { display: none; }

  .screen-box {
    background: #fff9f0;
    border-radius: 20px;
    padding: 32px 28px;
    text-align: center;
    max-width: 320px;
    width: 90%;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
  }

  .screen-box h2 {
    font-size: 1.5rem;
    font-weight: 900;
    color: #2e7d32;
    margin-bottom: 8px;
  }

  .screen-box p {
    font-size: 0.85rem;
    color: #5d4037;
    margin-bottom: 16px;
    line-height: 1.5;
  }

  .screen-box .emoji-big {
    font-size: 3rem;
    margin-bottom: 12px;
  }

  .btn {
    display: inline-block;
    padding: 12px 32px;
    font-family: 'Nunito', sans-serif;
    font-size: 1rem;
    font-weight: 900;
    color: #fff;
    background: linear-gradient(135deg, #66bb6a, #43a047);
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 4px;
  }

  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(76,175,80,0.4);
  }

  .btn:active {
    transform: translateY(0);
  }

  .btn.secondary {
    background: linear-gradient(135deg, #a1887f, #8d6e63);
  }

  .level-info {
    font-size: 0.75rem;
    color: #81c784;
    margin-top: 8px;
  }

  .back-link {
    display: block;
    text-align: center;
    margin-top: 10px;
    font-size: 0.75rem;
    color: #a5d6a7;
    text-decoration: none;
  }

  .back-link:hover { color: #66bb6a; }

  @media (max-width: 480px) {
    body { padding: 6px; }
    .game-wrapper { padding: 10px; border-radius: 16px; }
    .game-header h1 { font-size: 1.2rem; }
    .hud { font-size: 0.7rem; }
  }
</style>
</head>
<body>
<div class="game-wrapper">
  <div class="game-header">
    <h1>üêπ „Éè„É≥„Ç∞„É™„Éº„ÇØ„ÉÉ„Ç≠„Éº</h1>
    <div class="sub">Hungry Cookie</div>
  </div>

  <div class="hud">
    <div class="hud-left">
      <span id="levelDisplay">Lv.1</span>
      <span id="scoreDisplay">Score: 0</span>
    </div>
    <div class="hud-right">
      <span>HP</span>
      <div class="hp-bar-container">
        <div class="hp-bar" id="hpBar"></div>
      </div>
    </div>
  </div>

  <canvas id="gameCanvas" width="390" height="520"></canvas>

  <!-- Start Screen -->
  <div class="screen-overlay" id="startScreen">
    <div class="screen-box">
      <div class="emoji-big">üêπüß∫</div>
      <h2>„Éè„É≥„Ç∞„É™„Éº„ÇØ„ÉÉ„Ç≠„Éº</h2>
      <p>„Éè„É†„Çπ„Çø„Éº„ÅÆ„ÇØ„ÉÉ„Ç≠„Éº„Åå„Éê„Çπ„Ç±„ÉÉ„Éà„Åß<br>„Åä„ÅÑ„Åó„ÅÑ„ÇÇ„ÅÆ„Çí„Ç≠„É£„ÉÉ„ÉÅ„Åô„Çã„ÇàÔºÅ<br>ÊÇ™„ÅÑ„ÇÇ„ÅÆ„Å´„ÅØÊ∞ó„Çí„Å§„Åë„Å¶ÔºÅ</p>
      <button class="btn" id="startBtn">„Çπ„Çø„Éº„ÉàÔºÅ</button>
      <div class="level-info">‚Üê ‚Üí „Ç≠„Éº„Åã„Çø„ÉÉ„ÉÅ„ÅßÊìç‰Ωú</div>
    </div>
  </div>

  <!-- Level Clear Screen -->
  <div class="screen-overlay hidden" id="clearScreen">
    <div class="screen-box">
      <div class="emoji-big">üéâ</div>
      <h2>„É¨„Éô„É´„ÇØ„É™„Ç¢ÔºÅ</h2>
      <p id="clearMsg"></p>
      <button class="btn" id="nextLevelBtn">Ê¨°„ÅÆ„É¨„Éô„É´„Å∏</button>
    </div>
  </div>

  <!-- Game Over Screen -->
  <div class="screen-overlay hidden" id="gameOverScreen">
    <div class="screen-box">
      <div class="emoji-big">üòµ</div>
      <h2>„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h2>
      <p id="gameOverMsg"></p>
      <button class="btn" id="retryBtn">„ÇÇ„ÅÜ‰∏ÄÂõû</button>
      <button class="btn secondary" id="homeBtn">„Éõ„Éº„É†„Å∏</button>
    </div>
  </div>

  <!-- Game Complete Screen -->
  <div class="screen-overlay hidden" id="winScreen">
    <div class="screen-box">
      <div class="emoji-big">üèÜüêπ</div>
      <h2>„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅ</h2>
      <p id="winMsg"></p>
      <button class="btn" id="replayBtn">„ÇÇ„ÅÜ‰∏ÄÂõûÈÅä„Å∂</button>
      <button class="btn secondary" id="homeBtn2">„Éõ„Éº„É†„Å∏</button>
    </div>
  </div>

  <a href="index.html" class="back-link">‚Üê „Ç≤„Éº„É†‰∏ÄË¶ß„Å´Êàª„Çã</a>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Responsive canvas sizing
function resizeCanvas() {
  const wrapper = canvas.parentElement;
  const w = wrapper.clientWidth - 24;
  canvas.style.width = w + 'px';
  canvas.style.height = (w * canvas.height / canvas.width) + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Game constants
const W = canvas.width;
const H = canvas.height;
const HAMSTER_W = 60;
const HAMSTER_H = 55;
const BASKET_W = 70;
const BASKET_H = 30;
const ITEM_SIZE = 28;
const GROUND_Y = H - 20;

// Game state
let game = {
  state: 'start', // start, playing, paused, clear, gameover, win
  level: 1,
  score: 0,
  hp: 100,
  maxHp: 100,
  targetScore: 0,
  hamsterX: W / 2,
  hamsterY: GROUND_Y - HAMSTER_H,
  items: [],
  particles: [],
  spawnTimer: 0,
  spawnInterval: 60,
  frameCount: 0,
  damageFlash: 0,
  comboCount: 0,
  moveLeft: false,
  moveRight: false,
  touchX: null,
  treeSway: 0,
};

// Level configurations
const LEVELS = {
  1: {
    name: '„Å≤„Åæ„Çè„Çä„ÅÆÁ®Æ',
    description: '„Å≤„Åæ„Çè„Çä„ÅÆÁ®Æ„Çí„Ç≠„É£„ÉÉ„ÉÅ„Åó„Çà„ÅÜÔºÅ',
    targetScore: 150,
    spawnInterval: 50,
    speed: 2.5,
    items: [
      { type: 'sunflower_seed', chance: 1.0, points: 10, good: true }
    ]
  },
  2: {
    name: '„Éñ„É≠„ÉÉ„Ç≥„É™„Éº',
    description: '„Éñ„É≠„ÉÉ„Ç≥„É™„Éº„Çí„Ç≠„É£„ÉÉ„ÉÅÔºÅ„ÅÜ„Çì„Å°„Å´Ê∞ó„Çí„Å§„Åë„Å¶ÔºÅ',
    targetScore: 250,
    spawnInterval: 42,
    speed: 3.0,
    items: [
      { type: 'broccoli', chance: 0.75, points: 15, good: true },
      { type: 'poop', chance: 0.25, points: 0, good: false, damage: 20 }
    ]
  },
  3: {
    name: '„ÇØ„ÉÉ„Ç≠„Éº',
    description: '„ÇØ„ÉÉ„Ç≠„Éº„Çí„Ç≠„É£„ÉÉ„ÉÅÔºÅÂç±Èô∫„Åå„ÅÑ„Å£„Å±„ÅÑÔºÅ',
    targetScore: 400,
    spawnInterval: 32,
    speed: 3.8,
    items: [
      { type: 'cookie_food', chance: 0.45, points: 20, good: true },
      { type: 'poop', chance: 0.30, points: 0, good: false, damage: 20 },
      { type: 'can', chance: 0.25, points: 0, good: false, damage: 25 }
    ]
  }
};

// Drawing functions

function drawTree(x, leavesColor) {
  const sway = Math.sin(game.treeSway + x * 0.01) * 3;
  // Trunk
  ctx.fillStyle = '#8d6e63';
  ctx.fillRect(x - 8, 0, 16, 80);
  // Branches
  ctx.fillStyle = '#6d4c41';
  ctx.beginPath();
  ctx.moveTo(x - 8, 40);
  ctx.lineTo(x - 30 + sway, 20);
  ctx.lineTo(x - 25 + sway, 15);
  ctx.lineTo(x - 5, 35);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + 8, 30);
  ctx.lineTo(x + 35 + sway, 10);
  ctx.lineTo(x + 30 + sway, 5);
  ctx.lineTo(x + 5, 25);
  ctx.fill();
  // Leaves
  ctx.fillStyle = leavesColor;
  ctx.beginPath();
  ctx.arc(x + sway, -5, 35, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x - 20 + sway, 10, 25, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + 22 + sway, 8, 27, 0, Math.PI * 2);
  ctx.fill();
}

function drawBackground() {
  // Sky gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  if (game.level === 1) {
    skyGrad.addColorStop(0, '#87CEEB');
    skyGrad.addColorStop(1, '#E8F5E9');
  } else if (game.level === 2) {
    skyGrad.addColorStop(0, '#FFE0B2');
    skyGrad.addColorStop(1, '#FFF8E1');
  } else {
    skyGrad.addColorStop(0, '#CE93D8');
    skyGrad.addColorStop(1, '#F3E5F5');
  }
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Ground
  ctx.fillStyle = '#8BC34A';
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
  ctx.fillStyle = '#689F38';
  ctx.fillRect(0, GROUND_Y, W, 4);

  // Grass tufts
  ctx.fillStyle = '#7CB342';
  for (let i = 0; i < W; i += 20) {
    ctx.beginPath();
    ctx.moveTo(i, GROUND_Y);
    ctx.lineTo(i + 5, GROUND_Y - 8);
    ctx.lineTo(i + 10, GROUND_Y);
    ctx.fill();
  }

  // Trees
  const leavesColors = ['#4CAF50', '#66BB6A', '#43A047'];
  drawTree(50, leavesColors[0]);
  drawTree(160, leavesColors[1]);
  drawTree(280, leavesColors[2]);
  drawTree(370, leavesColors[0]);
}

function drawHamster(x, y) {
  const bx = x;
  const by = y;

  // Basket
  ctx.fillStyle = '#8D6E63';
  ctx.beginPath();
  ctx.moveTo(bx - BASKET_W / 2, by + 10);
  ctx.lineTo(bx - BASKET_W / 2 + 8, by + BASKET_H + 10);
  ctx.lineTo(bx + BASKET_W / 2 - 8, by + BASKET_H + 10);
  ctx.lineTo(bx + BASKET_W / 2, by + 10);
  ctx.closePath();
  ctx.fill();
  // Basket lines
  ctx.strokeStyle = '#6D4C41';
  ctx.lineWidth = 1;
  for (let i = 0; i < 4; i++) {
    const ly = by + 14 + i * 7;
    const shrink = i * 1.5;
    ctx.beginPath();
    ctx.moveTo(bx - BASKET_W / 2 + 4 + shrink, ly);
    ctx.lineTo(bx + BASKET_W / 2 - 4 - shrink, ly);
    ctx.stroke();
  }
  // Basket rim
  ctx.fillStyle = '#A1887F';
  ctx.fillRect(bx - BASKET_W / 2 - 2, by + 7, BASKET_W + 4, 6);
  ctx.strokeStyle = '#6D4C41';
  ctx.lineWidth = 1;
  ctx.strokeRect(bx - BASKET_W / 2 - 2, by + 7, BASKET_W + 4, 6);

  // Body
  ctx.fillStyle = '#FFCC80';
  ctx.beginPath();
  ctx.ellipse(bx, by + 5, 22, 18, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#E6A23C';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Belly
  ctx.fillStyle = '#FFF8E1';
  ctx.beginPath();
  ctx.ellipse(bx, by + 10, 13, 10, 0, 0, Math.PI * 2);
  ctx.fill();

  // Head
  ctx.fillStyle = '#FFCC80';
  ctx.beginPath();
  ctx.arc(bx, by - 14, 18, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#E6A23C';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Ears
  ctx.fillStyle = '#FFCC80';
  ctx.beginPath();
  ctx.ellipse(bx - 14, by - 28, 7, 9, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#E6A23C';
  ctx.stroke();
  ctx.fillStyle = '#FFAB91';
  ctx.beginPath();
  ctx.ellipse(bx - 14, by - 28, 4, 5, -0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#FFCC80';
  ctx.beginPath();
  ctx.ellipse(bx + 14, by - 28, 7, 9, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#E6A23C';
  ctx.stroke();
  ctx.fillStyle = '#FFAB91';
  ctx.beginPath();
  ctx.ellipse(bx + 14, by - 28, 4, 5, 0.3, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  ctx.fillStyle = '#3E2723';
  ctx.beginPath();
  ctx.arc(bx - 7, by - 16, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(bx + 7, by - 16, 3, 0, Math.PI * 2);
  ctx.fill();
  // Eye highlights
  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(bx - 6, by - 17, 1.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(bx + 8, by - 17, 1.2, 0, Math.PI * 2);
  ctx.fill();

  // Nose
  ctx.fillStyle = '#FF8A80';
  ctx.beginPath();
  ctx.ellipse(bx, by - 11, 2.5, 2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Mouth
  ctx.strokeStyle = '#5D4037';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(bx - 2, by - 9, 3, 0.1, Math.PI * 0.9);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(bx + 2, by - 9, 3, 0.1, Math.PI * 0.9);
  ctx.stroke();

  // Cheeks
  ctx.fillStyle = 'rgba(255,138,128,0.4)';
  ctx.beginPath();
  ctx.ellipse(bx - 15, by - 10, 5, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(bx + 15, by - 10, 5, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Whiskers
  ctx.strokeStyle = '#BCAAA4';
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(bx - 12, by - 11);
  ctx.lineTo(bx - 28, by - 14);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(bx - 12, by - 9);
  ctx.lineTo(bx - 27, by - 7);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(bx + 12, by - 11);
  ctx.lineTo(bx + 28, by - 14);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(bx + 12, by - 9);
  ctx.lineTo(bx + 27, by - 7);
  ctx.stroke();

  // Arms holding basket
  ctx.strokeStyle = '#FFCC80';
  ctx.lineWidth = 5;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(bx - 20, by + 2);
  ctx.lineTo(bx - BASKET_W / 2 + 5, by + 12);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(bx + 20, by + 2);
  ctx.lineTo(bx + BASKET_W / 2 - 5, by + 12);
  ctx.stroke();
  ctx.strokeStyle = '#E6A23C';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(bx - 20, by + 2);
  ctx.lineTo(bx - BASKET_W / 2 + 5, by + 12);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(bx + 20, by + 2);
  ctx.lineTo(bx + BASKET_W / 2 - 5, by + 12);
  ctx.stroke();

  // Feet
  ctx.fillStyle = '#FFCC80';
  ctx.beginPath();
  ctx.ellipse(bx - 10, by + BASKET_H + 12, 8, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(bx + 10, by + BASKET_H + 12, 8, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Damage flash
  if (game.damageFlash > 0) {
    ctx.fillStyle = `rgba(255,0,0,${game.damageFlash * 0.3})`;
    ctx.beginPath();
    ctx.ellipse(bx, by, 35, 45, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawSunflowerSeed(x, y, rot) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rot);
  // Seed shape
  ctx.fillStyle = '#5D4037';
  ctx.beginPath();
  ctx.ellipse(0, 0, 5, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  // Stripe
  ctx.fillStyle = '#8D6E63';
  ctx.beginPath();
  ctx.ellipse(0, 0, 2, 9, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawBroccoli(x, y) {
  ctx.save();
  ctx.translate(x, y);
  // Stem
  ctx.fillStyle = '#689F38';
  ctx.fillRect(-3, 2, 6, 10);
  // Florets
  ctx.fillStyle = '#4CAF50';
  ctx.beginPath();
  ctx.arc(-6, -2, 7, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(6, -2, 7, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(0, -7, 7, 0, Math.PI * 2);
  ctx.fill();
  // Highlights
  ctx.fillStyle = '#66BB6A';
  ctx.beginPath();
  ctx.arc(-4, -5, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(4, -4, 2.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawCookieFood(x, y) {
  ctx.save();
  ctx.translate(x, y);
  // Cookie base
  ctx.fillStyle = '#D4A574';
  ctx.beginPath();
  ctx.arc(0, 0, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#B8860B';
  ctx.lineWidth = 1;
  ctx.stroke();
  // Chocolate chips
  ctx.fillStyle = '#5D4037';
  ctx.beginPath(); ctx.arc(-4, -4, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(5, -2, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(-2, 5, 2.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(4, 4, 1.8, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}

function drawPoop(x, y) {
  ctx.save();
  ctx.translate(x, y);
  // Poop shape
  ctx.fillStyle = '#795548';
  // Bottom
  ctx.beginPath();
  ctx.ellipse(0, 5, 10, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  // Middle
  ctx.beginPath();
  ctx.ellipse(0, -1, 8, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  // Top
  ctx.beginPath();
  ctx.ellipse(0, -7, 5, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  // Tip
  ctx.beginPath();
  ctx.moveTo(-2, -11);
  ctx.quadraticCurveTo(3, -16, 4, -11);
  ctx.fill();
  // Face
  ctx.fillStyle = '#FFF';
  ctx.beginPath(); ctx.arc(-3, -2, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(3, -2, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#3E2723';
  ctx.beginPath(); ctx.arc(-3, -2, 0.8, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(3, -2, 0.8, 0, Math.PI * 2); ctx.fill();
  // Stink lines
  ctx.strokeStyle = '#A5D6A7';
  ctx.lineWidth = 1;
  ctx.setLineDash([2, 2]);
  ctx.beginPath();
  ctx.moveTo(-6, -12);
  ctx.quadraticCurveTo(-8, -18, -5, -22);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(2, -14);
  ctx.quadraticCurveTo(1, -20, 4, -24);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}

function drawCan(x, y, rot) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rot);
  // Can body
  ctx.fillStyle = '#90A4AE';
  ctx.beginPath();
  ctx.roundRect(-7, -10, 14, 20, 2);
  ctx.fill();
  ctx.strokeStyle = '#607D8B';
  ctx.lineWidth = 1;
  ctx.stroke();
  // Can top
  ctx.fillStyle = '#B0BEC5';
  ctx.beginPath();
  ctx.ellipse(0, -10, 7, 3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#607D8B';
  ctx.stroke();
  // Label
  ctx.fillStyle = '#E53935';
  ctx.fillRect(-6, -4, 12, 8);
  // Ring pull
  ctx.strokeStyle = '#78909C';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(0, -12, 3, 2, 0, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();
}

function drawItem(item) {
  switch (item.type) {
    case 'sunflower_seed':
      drawSunflowerSeed(item.x, item.y, item.rot);
      break;
    case 'broccoli':
      drawBroccoli(item.x, item.y);
      break;
    case 'cookie_food':
      drawCookieFood(item.x, item.y);
      break;
    case 'poop':
      drawPoop(item.x, item.y);
      break;
    case 'can':
      drawCan(item.x, item.y, item.rot);
      break;
  }
}

function drawParticles() {
  for (const p of game.particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawScorePopup(item) {
  if (item.popup && item.popupTimer > 0) {
    ctx.globalAlpha = item.popupTimer / 30;
    ctx.font = '900 16px Nunito';
    ctx.fillStyle = item.popupColor;
    ctx.textAlign = 'center';
    ctx.fillText(item.popupText, item.popupX, item.popupY - (30 - item.popupTimer));
    ctx.globalAlpha = 1;
  }
}

// Particle system
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    game.particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6 - 2,
      size: Math.random() * 4 + 2,
      color,
      life: 1
    });
  }
}

// Popups
let popups = [];
function addPopup(x, y, text, color) {
  popups.push({ x, y, text, color, timer: 40 });
}

function updatePopups() {
  for (let i = popups.length - 1; i >= 0; i--) {
    popups[i].timer--;
    popups[i].y -= 1.2;
    if (popups[i].timer <= 0) popups.splice(i, 1);
  }
}

function drawPopups() {
  for (const p of popups) {
    ctx.globalAlpha = Math.min(1, p.timer / 15);
    ctx.font = '900 18px Nunito';
    ctx.textAlign = 'center';
    ctx.fillStyle = p.color;
    ctx.fillText(p.text, p.x, p.y);
    ctx.globalAlpha = 1;
  }
}

// Spawn items
function spawnItem() {
  const levelConfig = LEVELS[game.level];
  const roll = Math.random();
  let cumulative = 0;
  let chosen = levelConfig.items[0];

  for (const item of levelConfig.items) {
    cumulative += item.chance;
    if (roll <= cumulative) {
      chosen = item;
      break;
    }
  }

  game.items.push({
    type: chosen.type,
    x: Math.random() * (W - 40) + 20,
    y: -20,
    speed: levelConfig.speed + Math.random() * 1.0,
    rot: 0,
    rotSpeed: (Math.random() - 0.5) * 0.08,
    wobble: Math.random() * Math.PI * 2,
    wobbleSpeed: 0.03 + Math.random() * 0.02,
    points: chosen.points,
    good: chosen.good,
    damage: chosen.damage || 0
  });
}

// Collision check
function checkCatch(item) {
  const basketTop = game.hamsterY + 7;
  const basketLeft = game.hamsterX - BASKET_W / 2;
  const basketRight = game.hamsterX + BASKET_W / 2;

  return (
    item.y + ITEM_SIZE / 2 > basketTop &&
    item.y - ITEM_SIZE / 2 < basketTop + BASKET_H &&
    item.x > basketLeft &&
    item.x < basketRight
  );
}

// Update game
function update() {
  if (game.state !== 'playing') return;

  game.frameCount++;
  game.treeSway += 0.02;

  // Move hamster
  const speed = 5;
  if (game.moveLeft) {
    game.hamsterX -= speed;
  }
  if (game.moveRight) {
    game.hamsterX += speed;
  }
  if (game.touchX !== null) {
    const canvasRect = canvas.getBoundingClientRect();
    const scaleX = W / canvasRect.width;
    const targetX = game.touchX * scaleX;
    const diff = targetX - game.hamsterX;
    game.hamsterX += diff * 0.15;
  }

  // Clamp position
  game.hamsterX = Math.max(BASKET_W / 2 + 5, Math.min(W - BASKET_W / 2 - 5, game.hamsterX));

  // Spawn items
  game.spawnTimer++;
  const levelConfig = LEVELS[game.level];
  if (game.spawnTimer >= levelConfig.spawnInterval) {
    game.spawnTimer = 0;
    spawnItem();
  }

  // Update items
  for (let i = game.items.length - 1; i >= 0; i--) {
    const item = game.items[i];
    item.y += item.speed;
    item.rot += item.rotSpeed;
    item.wobble += item.wobbleSpeed;
    item.x += Math.sin(item.wobble) * 0.5;

    // Check catch
    if (checkCatch(item)) {
      if (item.good) {
        game.score += item.points;
        game.comboCount++;
        const bonus = game.comboCount >= 5 ? ' COMBO!' : '';
        addPopup(item.x, item.y, '+' + item.points + bonus, '#2E7D32');
        spawnParticles(item.x, item.y, '#FFD54F', 8);

        // Check level clear
        if (game.score >= levelConfig.targetScore) {
          if (game.level >= 3) {
            game.state = 'win';
            showWinScreen();
          } else {
            game.state = 'clear';
            showClearScreen();
          }
        }
      } else {
        game.hp -= item.damage;
        game.damageFlash = 5;
        game.comboCount = 0;
        addPopup(item.x, item.y, '-' + item.damage, '#E53935');
        spawnParticles(item.x, item.y, '#8D6E63', 6);

        if (game.hp <= 0) {
          game.hp = 0;
          game.state = 'gameover';
          showGameOverScreen();
        }
      }
      game.items.splice(i, 1);
      continue;
    }

    // Remove if off screen
    if (item.y > H + 20) {
      if (item.good) {
        game.comboCount = 0;
      }
      game.items.splice(i, 1);
    }
  }

  // Update particles
  for (let i = game.particles.length - 1; i >= 0; i--) {
    const p = game.particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15;
    p.life -= 0.03;
    if (p.life <= 0) game.particles.splice(i, 1);
  }

  updatePopups();

  // Damage flash
  if (game.damageFlash > 0) game.damageFlash -= 0.2;

  // Update HUD
  updateHUD();
}

function updateHUD() {
  document.getElementById('levelDisplay').textContent = 'Lv.' + game.level;
  document.getElementById('scoreDisplay').textContent = 'Score: ' + game.score + ' / ' + LEVELS[game.level].targetScore;
  const hpBar = document.getElementById('hpBar');
  const hpPercent = (game.hp / game.maxHp) * 100;
  hpBar.style.width = hpPercent + '%';
  hpBar.className = 'hp-bar';
  if (hpPercent <= 25) hpBar.classList.add('danger');
  else if (hpPercent <= 50) hpBar.classList.add('warning');
}

// Draw everything
function draw() {
  ctx.clearRect(0, 0, W, H);

  drawBackground();

  // Items
  for (const item of game.items) {
    drawItem(item);
  }

  // Hamster
  drawHamster(game.hamsterX, game.hamsterY);

  // Particles
  drawParticles();

  // Popups
  drawPopups();

  // Level name indicator
  if (game.state === 'playing') {
    ctx.font = '700 12px Nunito';
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.textAlign = 'center';
    ctx.fillText(LEVELS[game.level].name, W / 2, H - 5);
  }
}

// Game loop
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// Screen management
function hideAllScreens() {
  document.getElementById('startScreen').classList.add('hidden');
  document.getElementById('clearScreen').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('winScreen').classList.add('hidden');
}

function showClearScreen() {
  const screen = document.getElementById('clearScreen');
  screen.classList.remove('hidden');
  document.getElementById('clearMsg').textContent =
    '„É¨„Éô„É´' + game.level + '„ÇØ„É™„Ç¢ÔºÅ„Çπ„Ç≥„Ç¢: ' + game.score;
}

function showGameOverScreen() {
  const screen = document.getElementById('gameOverScreen');
  screen.classList.remove('hidden');
  document.getElementById('gameOverMsg').textContent =
    '„Çπ„Ç≥„Ç¢: ' + game.score + ' („É¨„Éô„É´' + game.level + ')';
}

function showWinScreen() {
  const screen = document.getElementById('winScreen');
  screen.classList.remove('hidden');
  document.getElementById('winMsg').textContent =
    '„Åô„Åπ„Å¶„ÅÆ„É¨„Éô„É´„Çí„ÇØ„É™„Ç¢„Åó„Åü„ÇàÔºÅ\nÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ' + game.score;
}

function startGame() {
  game.state = 'playing';
  game.level = 1;
  game.score = 0;
  game.hp = 100;
  game.items = [];
  game.particles = [];
  game.spawnTimer = 0;
  game.frameCount = 0;
  game.damageFlash = 0;
  game.comboCount = 0;
  game.hamsterX = W / 2;
  popups = [];
  hideAllScreens();
  updateHUD();
}

function nextLevel() {
  game.level++;
  game.state = 'playing';
  game.items = [];
  game.particles = [];
  game.spawnTimer = 0;
  game.damageFlash = 0;
  game.comboCount = 0;
  // Restore some HP on level clear
  game.hp = Math.min(game.maxHp, game.hp + 30);
  popups = [];
  hideAllScreens();
  updateHUD();
}

// Controls
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'a') game.moveLeft = true;
  if (e.key === 'ArrowRight' || e.key === 'd') game.moveRight = true;
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'a') game.moveLeft = false;
  if (e.key === 'ArrowRight' || e.key === 'd') game.moveRight = false;
});

// Touch controls
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  game.touchX = touch.clientX - rect.left;
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  game.touchX = touch.clientX - rect.left;
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  game.touchX = null;
});

// Mouse controls
canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  game.touchX = e.clientX - rect.left;
});

canvas.addEventListener('mousemove', (e) => {
  if (e.buttons === 1) {
    const rect = canvas.getBoundingClientRect();
    game.touchX = e.clientX - rect.left;
  }
});

canvas.addEventListener('mouseup', () => {
  game.touchX = null;
});

// Button handlers
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('nextLevelBtn').addEventListener('click', nextLevel);
document.getElementById('retryBtn').addEventListener('click', startGame);
document.getElementById('replayBtn').addEventListener('click', startGame);
document.getElementById('homeBtn').addEventListener('click', () => {
  window.location.href = 'index.html';
});
document.getElementById('homeBtn2').addEventListener('click', () => {
  window.location.href = 'index.html';
});

// Start
updateHUD();
gameLoop();
</script>
</body>
</html>
