<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>„ÇØ„ÉÉ„Ç≠„Éº„Ç®„Çπ„Ç±„Éº„Éó - „Éè„É†„Çπ„Çø„Éº„ÅÆÂ§ßÂÜíÈô∫</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Nunito', sans-serif;
    background: #1a1208;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: manipulation;
  }

  #game-wrapper {
    position: relative;
    width: 100%;
    max-width: 560px;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px;
  }

  #hud {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 480px;
    padding: 8px 12px;
    margin-bottom: 6px;
    background: rgba(255,255,255,0.08);
    border-radius: 12px;
  }

  #hud .hud-item {
    font-size: 0.85rem;
    font-weight: 700;
    color: #f5d79e;
  }

  #hud .hud-lives {
    font-size: 1rem;
  }

  #hud .hud-level {
    color: #a78bfa;
  }

  canvas {
    display: block;
    border-radius: 8px;
    image-rendering: pixelated;
    max-width: 100%;
    touch-action: none;
  }

  #overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(26, 18, 8, 0.92);
    border-radius: 8px;
    z-index: 10;
    padding: 20px;
    text-align: center;
  }

  #overlay.hidden { display: none; }

  #overlay h2 {
    font-size: 1.6rem;
    font-weight: 900;
    color: #fde68a;
    margin-bottom: 8px;
  }

  #overlay p {
    font-size: 0.85rem;
    color: #e2d5c0;
    margin-bottom: 16px;
    line-height: 1.6;
  }

  #overlay .highlight {
    color: #f59e0b;
    font-weight: 700;
  }

  #overlay button {
    padding: 12px 36px;
    font-family: 'Nunito', sans-serif;
    font-size: 1rem;
    font-weight: 900;
    border: none;
    border-radius: 50px;
    background: linear-gradient(135deg, #f59e0b, #d97706);
    color: #fff;
    cursor: pointer;
    transition: transform 0.15s;
    -webkit-tap-highlight-color: transparent;
  }

  #overlay button:hover { transform: scale(1.05); }
  #overlay button:active { transform: scale(0.97); }

  #mobile-controls {
    display: none;
    width: 100%;
    max-width: 480px;
    margin-top: 10px;
  }

  .dpad {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    gap: 4px;
    width: 180px;
    height: 180px;
    margin: 0 auto;
  }

  .dpad-btn {
    background: rgba(255,255,255,0.12);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 12px;
    color: #fde68a;
    font-size: 1.6rem;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    transition: background 0.1s;
  }

  .dpad-btn:active, .dpad-btn.active {
    background: rgba(245, 158, 11, 0.4);
    border-color: #f59e0b;
  }

  .dpad-empty { background: transparent; border: none; }

  #back-link {
    display: inline-block;
    margin-top: 12px;
    font-size: 0.75rem;
    color: #a78bfa;
    text-decoration: none;
  }

  #back-link:hover { color: #c4b5fd; }

  @media (max-width: 600px) {
    #mobile-controls { display: block; }
    #hud { max-width: 100%; }
    #hud .hud-item { font-size: 0.75rem; }
  }

  @media (max-width: 400px) {
    .dpad { width: 150px; height: 150px; }
    .dpad-btn { font-size: 1.3rem; border-radius: 10px; }
    #overlay h2 { font-size: 1.3rem; }
    #overlay p { font-size: 0.78rem; }
  }

  @media (min-height: 800px) and (max-width: 600px) {
    .dpad { width: 200px; height: 200px; }
  }
</style>
</head>
<body>

<div id="game-wrapper">
  <div id="hud">
    <span class="hud-item hud-level" id="hud-level">„É¨„Éô„É´ 1</span>
    <span class="hud-item" id="hud-score">„Çπ„Ç≥„Ç¢: 0</span>
    <span class="hud-item hud-lives" id="hud-lives">üêπüêπüêπ</span>
  </div>

  <canvas id="game"></canvas>

  <div id="overlay">
    <h2>üêπ „ÇØ„ÉÉ„Ç≠„Éº„Ç®„Çπ„Ç±„Éº„Éó üêπ</h2>
    <p>
      „Éè„É†„Çπ„Çø„Éº„ÅÆ„ÇØ„ÉÉ„Ç≠„Éº„ÇíÂãï„Åã„Åó„Å¶„ÄÅ<span class="highlight">Êïµ</span>„Åã„ÇâÈÄÉ„Åí„Çà„ÅÜÔºÅ<br>
      „Å≤„Åæ„Çè„Çä„ÅÆÁ®Æ„ÇíÂÖ®ÈÉ®È£ü„Åπ„Åü„Çâ„ÇØ„É™„Ç¢ÔºÅ<br><br>
      üêç „É¨„Éô„É´1: „Éò„Éì &nbsp; ü¶ñ „É¨„Éô„É´2: ÊÅêÁ´ú &nbsp; üêª „É¨„Éô„É´3: „Ç∞„É™„Ç∫„É™„Éº„Éô„Ç¢<br><br>
      üéÆ Áü¢Âç∞„Ç≠„Éº / „Çπ„ÉØ„Ç§„Éó / D-Pad „ÅßÊìç‰Ωú<br>
      üç™ „ÇØ„ÉÉ„Ç≠„Éº„ÇíÂèñ„Çã„Å®„ÄÅÊïµ„Çí„ÇÑ„Å£„Å§„Åë„Çâ„Çå„Çã„ÇàÔºÅ
    </p>
    <button id="start-btn">„Çπ„Çø„Éº„Éà</button>
    <a href="index.html" id="home-btn" class="hidden" style="display:none; margin-top:10px; padding:10px 30px; font-family:'Nunito',sans-serif; font-size:0.9rem; font-weight:700; border:2px solid #a78bfa; border-radius:50px; background:transparent; color:#a78bfa; text-decoration:none; transition:transform 0.15s;">„Éõ„Éº„É†„Éö„Éº„Ç∏„Å∏</a>
  </div>

  <div id="mobile-controls">
    <div class="dpad">
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-dir="up">‚ñ≤</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-dir="left">‚óÄ</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-dir="right">‚ñ∂</div>
      <div class="dpad-empty"></div>
      <div class="dpad-btn" data-dir="down">‚ñº</div>
      <div class="dpad-empty"></div>
    </div>
  </div>

  <a href="index.html" id="back-link">‚Üê „Ç≤„Éº„É†‰∏ÄË¶ß„Å´Êàª„Çã</a>
</div>

<script>
(function() {
  'use strict';

  // ===== Constants =====
  const TILE = 24;
  const COLS = 19;
  const ROWS = 21;
  const W = COLS * TILE;
  const H = ROWS * TILE;

  const DIR = { NONE: -1, UP: 0, DOWN: 1, LEFT: 2, RIGHT: 3 };
  const DX = [0, 0, -1, 1];
  const DY = [-1, 1, 0, 0];

  // Tile types
  const EMPTY = 0;
  const WALL = 1;
  const DOT = 2;
  const POWER = 3;
  const GHOST_HOME = 4;
  const TUNNEL = 5;

  // Enemy config per level: type, colors, names
  const ENEMY_TYPES = {
    1: { type: 'snake', colors: ['#4a8c3f', '#8b4513', '#6b6b6b', '#8b0000'], names: ['„Éü„Éâ„É™', '„ÉÅ„É£„Ç§„É≠', '„Ç∞„É¨„Éº', '„Ç¢„Ç´„Éò„Éì'], label: '„Éò„Éì' },
    2: { type: 'dino',  colors: ['#2e8b57', '#b8860b', '#708090', '#a0522d'], names: ['„É©„Éó„Éà„É´', '„ÉÜ„Ç£„É©„Éé', '„Éà„É™„Ç±„É©', '„Éó„ÉÜ„É©'], label: 'ÊÅêÁ´ú' },
    3: { type: 'bear',  colors: ['#6b4226', '#8b6914', '#5c4033', '#7a3b2e'], names: ['„Ç∞„É™„Ç∫„É™„Éº', '„Ç≥„Éá„Ç£„Ç¢„ÉÉ„ÇØ', '„Éí„Ç∞„Éû', '„ÉÑ„Ç≠„Éé„ÉØ'], label: '„Ç∞„É™„Ç∫„É™„Éº„Éô„Ç¢' },
  };
  function getEnemyConfig() { return ENEMY_TYPES[state.level] || ENEMY_TYPES[1]; }
  const GHOST_COLORS = ENEMY_TYPES[1].colors;
  const GHOST_NAMES = ENEMY_TYPES[1].names;

  // ===== Maze layouts per level =====
  // 1=wall, 0=dot, 2=empty, 3=power, 4=ghost home, 5=tunnel
  const MAZE_TEMPLATES = [
    // Level 1 - Classic layout
    [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
      [1,3,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,3,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
      [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
      [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
      [1,1,1,1,0,1,2,2,2,2,2,2,2,1,0,1,1,1,1],
      [1,1,1,1,0,1,2,1,1,4,1,1,2,1,0,1,1,1,1],
      [5,2,2,2,0,2,2,1,4,4,4,1,2,2,0,2,2,2,5],
      [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
      [1,1,1,1,0,1,2,2,2,2,2,2,2,1,0,1,1,1,1],
      [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
      [1,3,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,3,1],
      [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
      [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
      [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ],
    // Level 2 - More open
    [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],
      [1,3,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,3,1],
      [1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],
      [1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
      [1,0,1,0,1,1,1,1,2,1,2,1,1,1,1,0,1,0,1],
      [1,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,1],
      [1,1,1,0,1,1,2,1,1,4,1,1,2,1,1,0,1,1,1],
      [5,2,2,0,0,1,2,1,4,4,4,1,2,1,0,0,2,2,5],
      [1,1,1,0,1,1,2,1,1,1,1,1,2,1,1,0,1,1,1],
      [1,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,1],
      [1,0,1,0,1,1,1,1,2,1,2,1,1,1,1,0,1,0,1],
      [1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
      [1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1],
      [1,3,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,3,1],
      [1,0,1,1,1,0,1,0,0,0,0,0,1,0,1,1,1,0,1],
      [1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1],
      [1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ],
    // Level 3 - Tricky corridors
    [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1],
      [1,3,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,3,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,1],
      [1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1],
      [1,0,1,1,1,1,0,1,2,1,2,1,0,1,1,1,1,0,1],
      [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],
      [1,0,1,1,0,1,2,1,1,4,1,1,2,1,0,1,1,0,1],
      [5,2,0,0,0,1,2,1,4,4,4,1,2,1,0,0,0,2,5],
      [1,0,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,0,1],
      [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],
      [1,0,1,1,1,1,0,1,2,1,2,1,0,1,1,1,1,0,1],
      [1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1],
      [1,1,0,1,0,1,1,0,0,0,0,0,1,1,0,1,0,1,1],
      [1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1],
      [1,3,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,3,1],
      [1,0,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1],
      [1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ],
  ];

  // ===== Canvas setup =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width = W;
  canvas.height = H;

  // Scale canvas for high-DPI
  function resizeCanvas() {
    const wrapper = document.getElementById('game-wrapper');
    const maxW = Math.min(wrapper.clientWidth - 16, 560);
    const scale = Math.min(maxW / W, 1);
    canvas.style.width = (W * scale) + 'px';
    canvas.style.height = (H * scale) + 'px';
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // ===== Game State =====
  let state = {
    maze: [],
    dots: 0,
    dotsEaten: 0,
    score: 0,
    lives: 3,
    level: 1,
    running: false,
    paused: false,
    gameOver: false,
    won: false,
    powerMode: false,
    powerTimer: 0,
    cookie: null,
    ghosts: [],
    frameTick: 0,
  };

  // ===== Cookie (Player) =====
  function createCookie() {
    return {
      x: 9, y: 15,
      dir: DIR.NONE,
      nextDir: DIR.NONE,
      moveProgress: 0,
      mouthAngle: 0,
      mouthDir: 1,
    };
  }

  // ===== Ghosts =====
  function createGhost(i) {
    const homeX = 8 + i;
    const homeY = 9;
    return {
      x: homeX, y: homeY,
      homeX: homeX, homeY: homeY,
      dir: DIR.UP,
      moveProgress: 0,
      color: getEnemyConfig().colors[i],
      mode: 'home', // home, chase, scatter, frightened, eaten
      homeTimer: i * 80 + 40,
      frightTimer: 0,
      eatenReturn: false,
      eyeDir: DIR.LEFT,
      speed: 0.9 + state.level * 0.08,
    };
  }

  // ===== Maze helpers =====
  function loadMaze(level) {
    const idx = (level - 1) % MAZE_TEMPLATES.length;
    const template = MAZE_TEMPLATES[idx];
    state.maze = [];
    state.dots = 0;
    for (let r = 0; r < ROWS; r++) {
      state.maze[r] = [];
      for (let c = 0; c < COLS; c++) {
        const v = template[r][c];
        state.maze[r][c] = v;
        if (v === DOT || v === POWER) state.dots++;
      }
    }
  }

  function tileAt(x, y) {
    if (y < 0 || y >= ROWS) return WALL;
    if (x < 0 || x >= COLS) {
      // tunnel check
      if (y === 9) return TUNNEL;
      return WALL;
    }
    return state.maze[y][x];
  }

  function isWalkable(x, y) {
    const t = tileAt(x, y);
    return t !== WALL;
  }

  function canMove(x, y, dir) {
    const nx = x + DX[dir];
    const ny = y + DY[dir];
    // Tunnel wrap
    if (nx < 0 && y === 9) return true;
    if (nx >= COLS && y === 9) return true;
    return isWalkable(nx, ny) && tileAt(nx, ny) !== GHOST_HOME;
  }

  function canMoveGhost(x, y, dir, isEaten) {
    const nx = x + DX[dir];
    const ny = y + DY[dir];
    if (nx < 0 && y === 9) return true;
    if (nx >= COLS && y === 9) return true;
    if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) return false;
    const t = state.maze[ny][nx];
    if (t === WALL) return false;
    return true;
  }

  // ===== Initialization =====
  function initLevel() {
    loadMaze(state.level);
    state.dotsEaten = 0;
    state.powerMode = false;
    state.powerTimer = 0;
    state.cookie = createCookie();
    state.ghosts = [];
    for (let i = 0; i < Math.min(4, 2 + state.level); i++) {
      state.ghosts.push(createGhost(i));
    }
    state.frameTick = 0;
  }

  function startGame() {
    state.score = 0;
    state.lives = 3;
    state.level = 1;
    state.gameOver = false;
    state.won = false;
    initLevel();
    state.running = true;
    updateHUD();
    hideOverlay();
  }

  // ===== Movement =====
  const COOKIE_SPEED = 1.0;

  function moveCookie() {
    const c = state.cookie;

    // Continuously update direction from finger position while touching
    if (touchActive) {
      updateDirFromTouch(lastTouchX, lastTouchY);
    }

    if (c.dir === DIR.NONE && c.nextDir === DIR.NONE) return;

    // Try to switch to desired direction
    if (c.nextDir !== DIR.NONE && c.moveProgress === 0) {
      if (canMove(c.x, c.y, c.nextDir)) {
        c.dir = c.nextDir;
        c.nextDir = DIR.NONE;
      }
    }

    if (c.dir === DIR.NONE) return;

    if (c.moveProgress === 0) {
      if (!canMove(c.x, c.y, c.dir)) {
        c.dir = DIR.NONE;
        return;
      }
    }

    c.moveProgress += COOKIE_SPEED * 0.15;

    if (c.moveProgress >= 1) {
      c.moveProgress = 0;
      c.x += DX[c.dir];
      c.y += DY[c.dir];

      // Tunnel wrap
      if (c.x < 0) c.x = COLS - 1;
      if (c.x >= COLS) c.x = 0;

      // Eat dot
      if (state.maze[c.y] && state.maze[c.y][c.x] === DOT) {
        state.maze[c.y][c.x] = EMPTY;
        state.dotsEaten++;
        state.score += 10;
      } else if (state.maze[c.y] && state.maze[c.y][c.x] === POWER) {
        state.maze[c.y][c.x] = EMPTY;
        state.dotsEaten++;
        state.score += 50;
        activatePowerMode();
      }

      // Check level clear
      if (state.dotsEaten >= state.dots) {
        levelClear();
        return;
      }

      // Continue or stop
      if (!canMove(c.x, c.y, c.dir)) {
        c.dir = DIR.NONE;
      } else if (!touchActive && lastInputSource === 'touch') {
        c.dir = DIR.NONE;
      }
    }

    // Mouth animation
    c.mouthAngle += 0.15 * c.mouthDir;
    if (c.mouthAngle > 0.35) c.mouthDir = -1;
    if (c.mouthAngle < 0.02) c.mouthDir = 1;
  }

  function moveGhosts() {
    for (const g of state.ghosts) {
      // Home timer
      if (g.mode === 'home') {
        g.homeTimer--;
        if (g.homeTimer <= 0) {
          g.mode = 'chase';
          g.x = 9;
          g.y = 8;
          g.dir = DIR.UP;
          g.moveProgress = 0;
        }
        continue;
      }

      // Eaten: return home
      if (g.mode === 'eaten') {
        moveGhostToward(g, 9, 9, true);
        if (g.x === 9 && g.y === 9 && g.moveProgress === 0) {
          g.mode = 'chase';
          g.frightTimer = 0;
        }
        continue;
      }

      // Frightened countdown
      if (g.mode === 'frightened') {
        g.frightTimer--;
        if (g.frightTimer <= 0) {
          g.mode = 'chase';
        }
      }

      // Move
      const speed = g.mode === 'frightened' ? 0.055 : 0.07 + state.level * 0.005;
      g.moveProgress += speed;

      if (g.moveProgress >= 1) {
        g.moveProgress = 0;
        g.x += DX[g.dir];
        g.y += DY[g.dir];

        // Tunnel wrap
        if (g.x < 0) g.x = COLS - 1;
        if (g.x >= COLS) g.x = 0;

        // Choose next direction
        chooseGhostDir(g);
      }
    }
  }

  function chooseGhostDir(g) {
    const c = state.cookie;
    let targetX, targetY;

    if (g.mode === 'frightened') {
      // Random direction
      const dirs = [];
      for (let d = 0; d < 4; d++) {
        if (d === oppositeDir(g.dir)) continue;
        if (canMoveGhost(g.x, g.y, d, false)) dirs.push(d);
      }
      if (dirs.length > 0) {
        g.dir = dirs[Math.floor(Math.random() * dirs.length)];
      } else if (canMoveGhost(g.x, g.y, oppositeDir(g.dir), false)) {
        g.dir = oppositeDir(g.dir);
      }
      return;
    }

    // Chase target
    targetX = c.x;
    targetY = c.y;

    // Pick best direction toward target
    let bestDir = g.dir;
    let bestDist = Infinity;
    const dirs = [];

    for (let d = 0; d < 4; d++) {
      if (d === oppositeDir(g.dir)) continue;
      if (canMoveGhost(g.x, g.y, d, false)) dirs.push(d);
    }

    if (dirs.length === 0) {
      if (canMoveGhost(g.x, g.y, oppositeDir(g.dir), false)) {
        g.dir = oppositeDir(g.dir);
      }
      return;
    }

    for (const d of dirs) {
      const nx = g.x + DX[d];
      const ny = g.y + DY[d];
      const dist = Math.abs(nx - targetX) + Math.abs(ny - targetY);
      if (dist < bestDist) {
        bestDist = dist;
        bestDir = d;
      }
    }

    g.dir = bestDir;
    g.eyeDir = bestDir;
  }

  function moveGhostToward(g, tx, ty, isEaten) {
    const speed = 0.12;
    g.moveProgress += speed;

    if (g.moveProgress >= 1) {
      g.moveProgress = 0;
      g.x += DX[g.dir];
      g.y += DY[g.dir];
      if (g.x < 0) g.x = COLS - 1;
      if (g.x >= COLS) g.x = 0;

      // Pick direction toward target
      let bestDir = g.dir;
      let bestDist = Infinity;
      for (let d = 0; d < 4; d++) {
        if (canMoveGhost(g.x, g.y, d, isEaten)) {
          const nx = g.x + DX[d];
          const ny = g.y + DY[d];
          const dist = Math.abs(nx - tx) + Math.abs(ny - ty);
          if (dist < bestDist) {
            bestDist = dist;
            bestDir = d;
          }
        }
      }
      g.dir = bestDir;
      g.eyeDir = bestDir;
    }
  }

  function oppositeDir(d) {
    if (d === DIR.UP) return DIR.DOWN;
    if (d === DIR.DOWN) return DIR.UP;
    if (d === DIR.LEFT) return DIR.RIGHT;
    if (d === DIR.RIGHT) return DIR.LEFT;
    return DIR.NONE;
  }

  // ===== Collision =====
  function checkCollisions() {
    const c = state.cookie;
    for (const g of state.ghosts) {
      if (g.mode === 'home' || g.mode === 'eaten') continue;
      const dx = Math.abs((g.x + DX[g.dir] * g.moveProgress) - (c.x + (c.dir >= 0 ? DX[c.dir] * c.moveProgress : 0)));
      const dy = Math.abs((g.y + DY[g.dir] * g.moveProgress) - (c.y + (c.dir >= 0 ? DY[c.dir] * c.moveProgress : 0)));
      if (dx < 0.8 && dy < 0.8) {
        if (g.mode === 'frightened') {
          // Eat ghost
          g.mode = 'eaten';
          state.score += 200;
        } else {
          // Cookie caught
          cookieCaught();
          return;
        }
      }
    }
  }

  function cookieCaught() {
    state.lives--;
    updateHUD();
    if (state.lives <= 0) {
      state.gameOver = true;
      state.running = false;
      const enemyLabel = getEnemyConfig().label;
      showOverlay('„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº üò¢', '„Çπ„Ç≥„Ç¢: <span class="highlight">' + state.score + '</span><br>„É¨„Éô„É´ ' + state.level + 'Ôºà' + enemyLabel + 'Ôºâ„Åæ„ÅßÂà∞ÈÅîÔºÅ', '„ÇÇ„ÅÜ‰∏ÄÂõû', true);
    } else {
      // Reset positions
      state.cookie = createCookie();
      state.ghosts.forEach((g, i) => {
        g.x = 8 + i;
        g.y = 9;
        g.dir = DIR.UP;
        g.moveProgress = 0;
        g.mode = 'home';
        g.homeTimer = i * 80 + 40;
        g.frightTimer = 0;
      });
      state.powerMode = false;
      state.powerTimer = 0;
    }
  }

  // ===== Power mode =====
  function activatePowerMode() {
    state.powerMode = true;
    state.powerTimer = 300;
    for (const g of state.ghosts) {
      if (g.mode === 'chase' || g.mode === 'scatter') {
        g.mode = 'frightened';
        g.frightTimer = 300;
        g.dir = oppositeDir(g.dir);
      }
    }
  }

  // ===== Level clear =====
  function levelClear() {
    state.level++;
    if (state.level > 3) {
      state.running = false;
      state.won = true;
      showOverlay('üéâ ÂÖ®„ÇØ„É™„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅ üéâ', '„Çπ„Ç≥„Ç¢: <span class="highlight">' + state.score + '</span><br>„Åô„Åπ„Å¶„ÅÆ„É¨„Éô„É´„Çí„ÇØ„É™„Ç¢„Åó„Åü„ÇàÔºÅ', '„ÇÇ„ÅÜ‰∏ÄÂõû', true);
    } else {
      state.score += 500;
      const nextEnemy = getEnemyConfig();
      state.running = false;
      showOverlay('üéâ „É¨„Éô„É´„ÇØ„É™„Ç¢ÔºÅ üéâ', '„Çπ„Ç≥„Ç¢: <span class="highlight">' + state.score + '</span><br>Ê¨°„ÅÆÊïµ„ÅØ <span class="highlight">' + nextEnemy.label + '</span> „Å†ÔºÅÊ∞ó„Çí„Å§„Åë„Å¶ÔºÅ', 'Ê¨°„ÅÆ„É¨„Éô„É´„Å∏', false);
    }
  }

  // ===== Drawing =====
  function draw() {
    // Dark underground tunnel background
    ctx.fillStyle = '#1a1208';
    ctx.fillRect(0, 0, W, H);

    drawMaze();
    drawDots();
    drawCookie();
    drawGhosts();
  }

  function drawMaze() {
    // Tunnel/underground theme - earthy colors that change per level
    const wallColor = state.level === 1 ? '#5c3a1e' : state.level === 2 ? '#3d2b1f' : '#4a3728';
    const wallBorder = state.level === 1 ? '#8b6340' : state.level === 2 ? '#6b5040' : '#7a5a3a';

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (state.maze[r][c] === WALL) {
          const x = c * TILE;
          const y = r * TILE;
          ctx.fillStyle = wallColor;
          ctx.fillRect(x, y, TILE, TILE);

          // Draw borders only on walkable-adjacent sides
          ctx.strokeStyle = wallBorder;
          ctx.lineWidth = 2;
          if (r > 0 && state.maze[r-1][c] !== WALL) {
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + TILE, y); ctx.stroke();
          }
          if (r < ROWS-1 && state.maze[r+1][c] !== WALL) {
            ctx.beginPath(); ctx.moveTo(x, y + TILE); ctx.lineTo(x + TILE, y + TILE); ctx.stroke();
          }
          if (c > 0 && state.maze[r][c-1] !== WALL) {
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + TILE); ctx.stroke();
          }
          if (c < COLS-1 && state.maze[r][c+1] !== WALL) {
            ctx.beginPath(); ctx.moveTo(x + TILE, y); ctx.lineTo(x + TILE, y + TILE); ctx.stroke();
          }
        }
      }
    }
  }

  function drawDots() {
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const x = c * TILE + TILE / 2;
        const y = r * TILE + TILE / 2;
        if (state.maze[r][c] === DOT) {
          // Sunflower seed
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(Math.PI * 0.15);
          // Seed body (dark teardrop shape)
          ctx.fillStyle = '#3d3024';
          ctx.beginPath();
          ctx.ellipse(0, 0, 1.8, 3.2, 0, 0, Math.PI * 2);
          ctx.fill();
          // Seed stripe (light line)
          ctx.fillStyle = '#c0a878';
          ctx.beginPath();
          ctx.ellipse(0, 0, 0.5, 2.4, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        } else if (state.maze[r][c] === POWER) {
          // Cookie (food) power-up
          const pulse = Math.sin(state.frameTick * 0.1) * 1 + 7;
          ctx.save();
          ctx.translate(x, y);
          // Glow
          ctx.fillStyle = 'rgba(212, 148, 58, 0.25)';
          ctx.beginPath();
          ctx.arc(0, 0, pulse + 3, 0, Math.PI * 2);
          ctx.fill();
          // Cookie body
          ctx.fillStyle = '#d4943a';
          ctx.beginPath();
          ctx.arc(0, 0, pulse, 0, Math.PI * 2);
          ctx.fill();
          // Cookie edge highlight
          ctx.fillStyle = '#c07830';
          ctx.beginPath();
          ctx.arc(0, 0, pulse, 0, Math.PI * 2);
          ctx.lineWidth = 1;
          ctx.strokeStyle = '#a06020';
          ctx.stroke();
          // Chocolate chips
          ctx.fillStyle = '#5a2d0c';
          const chipScale = pulse / 7;
          const chipPositions = [[-2, -3], [3, -1], [-1, 3], [3, 2.5], [-3.5, 0.5]];
          for (const [cx, cy] of chipPositions) {
            ctx.beginPath();
            ctx.arc(cx * chipScale, cy * chipScale, 1.2 * chipScale, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }
      }
    }
  }

  function drawCookie() {
    const c = state.cookie;
    let px = c.x * TILE + TILE / 2;
    let py = c.y * TILE + TILE / 2;

    // Smooth movement
    if (c.dir >= 0) {
      px += DX[c.dir] * c.moveProgress * TILE;
      py += DY[c.dir] * c.moveProgress * TILE;
    }

    const r = TILE * 0.45;

    // Direction angle for facing
    let angle = 0;
    if (c.dir === DIR.RIGHT) angle = 0;
    else if (c.dir === DIR.DOWN) angle = Math.PI / 2;
    else if (c.dir === DIR.LEFT) angle = Math.PI;
    else if (c.dir === DIR.UP) angle = -Math.PI / 2;

    ctx.save();
    ctx.translate(px, py);
    ctx.rotate(angle);

    // Hamster body (round, warm orange-brown)
    ctx.fillStyle = '#e8a84c';
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fill();

    // White belly patch
    ctx.fillStyle = '#fff5e0';
    ctx.beginPath();
    ctx.ellipse(3, 2, r * 0.35, r * 0.45, 0, 0, Math.PI * 2);
    ctx.fill();

    // Ears
    ctx.fillStyle = '#d4943a';
    ctx.beginPath();
    ctx.arc(-5, -8, 3.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(5, -8, 3.5, 0, Math.PI * 2);
    ctx.fill();
    // Inner ears (pink)
    ctx.fillStyle = '#f0a0a0';
    ctx.beginPath();
    ctx.arc(-5, -8, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(5, -8, 2, 0, Math.PI * 2);
    ctx.fill();

    // Cheek pouches (puffy, animated when eating)
    const cheekPuff = Math.sin(state.frameTick * 0.08) * 0.5 + 4;
    ctx.fillStyle = '#f5c27a';
    ctx.beginPath();
    ctx.ellipse(-6, 1, cheekPuff, 3.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(6, 1, cheekPuff, 3.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Cheek blush
    ctx.fillStyle = 'rgba(255, 150, 150, 0.4)';
    ctx.beginPath();
    ctx.arc(-6, 1, 2.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(6, 1, 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    ctx.fillStyle = '#1a1a2e';
    ctx.beginPath();
    ctx.arc(-3, -3, 2.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(3, -3, 2.2, 0, Math.PI * 2);
    ctx.fill();
    // Eye highlights
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-2.3, -3.8, 0.9, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(3.7, -3.8, 0.9, 0, Math.PI * 2);
    ctx.fill();

    // Nose
    ctx.fillStyle = '#ff8fa0';
    ctx.beginPath();
    ctx.arc(0, -0.5, 1.5, 0, Math.PI * 2);
    ctx.fill();

    // Mouth (tiny smile)
    ctx.strokeStyle = '#8b5e34';
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.arc(-1.5, 1.5, 1.5, 0, Math.PI * 0.8);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(1.5, 1.5, 1.5, Math.PI * 0.2, Math.PI);
    ctx.stroke();

    // Whiskers
    ctx.strokeStyle = '#c0956a';
    ctx.lineWidth = 0.6;
    // Left whiskers
    ctx.beginPath(); ctx.moveTo(-6, -1); ctx.lineTo(-11, -3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-6, 0.5); ctx.lineTo(-11, 0.5); ctx.stroke();
    // Right whiskers
    ctx.beginPath(); ctx.moveTo(6, -1); ctx.lineTo(11, -3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(6, 0.5); ctx.lineTo(11, 0.5); ctx.stroke();

    ctx.restore();
  }

  function drawGhosts() {
    for (const g of state.ghosts) {
      if (g.mode === 'home') {
        // Draw floating in home
        drawGhostSprite(g.x * TILE + TILE/2, g.y * TILE + TILE/2 + Math.sin(state.frameTick * 0.08) * 3, g, true);
        continue;
      }

      let px = g.x * TILE + TILE / 2;
      let py = g.y * TILE + TILE / 2;
      if (g.dir >= 0) {
        px += DX[g.dir] * g.moveProgress * TILE;
        py += DY[g.dir] * g.moveProgress * TILE;
      }

      if (g.mode === 'eaten') {
        // Just eyes
        drawGhostEyes(px, py, g.eyeDir);
        continue;
      }

      drawGhostSprite(px, py, g, false);
    }
  }

  function drawGhostSprite(px, py, g, inHome) {
    const config = getEnemyConfig();
    if (config.type === 'dino') return drawDinoSprite(px, py, g, inHome);
    if (config.type === 'bear') return drawBearSprite(px, py, g, inHome);
    return drawSnakeSprite(px, py, g, inHome);
  }

  // ===== Snake sprite (Level 1) =====
  function drawSnakeSprite(px, py, g, inHome) {
    const r = TILE * 0.45;
    const frightened = g.mode === 'frightened';
    const flashing = frightened && g.frightTimer < 80 && Math.floor(state.frameTick / 8) % 2 === 0;

    let angle = 0;
    if (g.eyeDir === DIR.RIGHT) angle = 0;
    else if (g.eyeDir === DIR.DOWN) angle = Math.PI / 2;
    else if (g.eyeDir === DIR.LEFT) angle = Math.PI;
    else if (g.eyeDir === DIR.UP) angle = -Math.PI / 2;

    ctx.save();
    ctx.translate(px, py);
    ctx.rotate(angle);

    let bodyColor, bodyDark;
    if (frightened) {
      bodyColor = flashing ? '#aaddaa' : '#5577ff';
      bodyDark = flashing ? '#77aa77' : '#3355cc';
    } else {
      bodyColor = g.color;
      bodyDark = shadeColor(g.color, -30);
    }

    // Trailing segments
    const segCount = 4;
    const waveAmp = 3;
    for (let s = segCount; s >= 1; s--) {
      const segX = -s * 5;
      const segY = Math.sin(state.frameTick * 0.12 + s * 1.2) * waveAmp;
      const segR = r * (0.5 - s * 0.06);
      ctx.fillStyle = s % 2 === 0 ? bodyColor : bodyDark;
      ctx.beginPath();
      ctx.arc(segX, segY, segR, 0, Math.PI * 2);
      ctx.fill();
    }

    // Head
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r * 0.8, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = bodyDark;
    ctx.beginPath(); ctx.arc(-2, -3, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(2, 3, 2, 0, Math.PI * 2); ctx.fill();

    if (frightened) {
      ctx.fillStyle = flashing ? '#333' : '#fff';
      ctx.beginPath();
      ctx.arc(3, -3, 2.5, 0, Math.PI * 2);
      ctx.arc(3, 3, 2.5, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillStyle = '#ffe44d';
      ctx.beginPath(); ctx.arc(4, -3, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(4, 3, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.ellipse(4, -3, 0.8, 2.2, 0, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(4, 3, 0.8, 2.2, 0, 0, Math.PI * 2); ctx.fill();
    }

    const tongueOut = Math.sin(state.frameTick * 0.2) > 0;
    if (tongueOut && !frightened) {
      const tongueLen = 5 + Math.sin(state.frameTick * 0.3) * 2;
      ctx.strokeStyle = '#ff3355';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(r, 0); ctx.lineTo(r + tongueLen, 0); ctx.lineTo(r + tongueLen + 2, -2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(r + tongueLen, 0); ctx.lineTo(r + tongueLen + 2, 2); ctx.stroke();
    }

    ctx.restore();
  }

  // ===== Dinosaur sprite (Level 2) =====
  function drawDinoSprite(px, py, g, inHome) {
    const r = TILE * 0.45;
    const frightened = g.mode === 'frightened';
    const flashing = frightened && g.frightTimer < 80 && Math.floor(state.frameTick / 8) % 2 === 0;

    let angle = 0;
    if (g.eyeDir === DIR.RIGHT) angle = 0;
    else if (g.eyeDir === DIR.DOWN) angle = Math.PI / 2;
    else if (g.eyeDir === DIR.LEFT) angle = Math.PI;
    else if (g.eyeDir === DIR.UP) angle = -Math.PI / 2;

    ctx.save();
    ctx.translate(px, py);
    ctx.rotate(angle);

    let bodyColor, bodyDark;
    if (frightened) {
      bodyColor = flashing ? '#aaddaa' : '#5577ff';
      bodyDark = flashing ? '#77aa77' : '#3355cc';
    } else {
      bodyColor = g.color;
      bodyDark = shadeColor(g.color, -30);
    }

    // Tail (thick, tapering)
    const tailWave = Math.sin(state.frameTick * 0.1) * 2;
    ctx.fillStyle = bodyDark;
    ctx.beginPath();
    ctx.moveTo(-r * 0.5, 0);
    ctx.lineTo(-r * 1.8, tailWave - 2);
    ctx.lineTo(-r * 1.6, tailWave + 1);
    ctx.closePath();
    ctx.fill();

    // Body (upright oval, dinosaur torso)
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r * 0.85, 0, 0, Math.PI * 2);
    ctx.fill();

    // Belly (lighter)
    ctx.fillStyle = frightened ? bodyColor : shadeColor(g.color, 40);
    ctx.beginPath();
    ctx.ellipse(1, 2, r * 0.5, r * 0.55, 0, 0, Math.PI * 2);
    ctx.fill();

    // Spines on back
    if (!frightened) {
      ctx.fillStyle = shadeColor(g.color, -50);
      for (let i = 0; i < 3; i++) {
        const sx = -3 + i * 4;
        const sy = -r * 0.85;
        ctx.beginPath();
        ctx.moveTo(sx - 2, sy + 2);
        ctx.lineTo(sx, sy - 3);
        ctx.lineTo(sx + 2, sy + 2);
        ctx.closePath();
        ctx.fill();
      }
    }

    // Small arms
    ctx.strokeStyle = bodyDark;
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(4, 1); ctx.lineTo(7, 4); ctx.lineTo(6, 6); ctx.stroke();

    // Eyes
    if (frightened) {
      ctx.fillStyle = flashing ? '#333' : '#fff';
      ctx.beginPath();
      ctx.arc(4, -4, 2.5, 0, Math.PI * 2);
      ctx.arc(4, 3, 2.5, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // Dino eyes (round, reptilian)
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(5, -3, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(5, 3, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#cc2200';
      ctx.beginPath(); ctx.arc(5.5, -3, 1.8, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(5.5, 3, 1.8, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.arc(6, -3, 0.9, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(6, 3, 0.9, 0, Math.PI * 2); ctx.fill();
    }

    // Jaw/mouth with teeth
    if (!frightened) {
      const jawOpen = Math.sin(state.frameTick * 0.15) * 0.5 + 0.5;
      ctx.fillStyle = bodyDark;
      // Upper jaw
      ctx.beginPath();
      ctx.moveTo(r * 0.6, -r * 0.35);
      ctx.lineTo(r + 2, -1 * jawOpen);
      ctx.lineTo(r * 0.6, 0);
      ctx.closePath();
      ctx.fill();
      // Lower jaw
      ctx.beginPath();
      ctx.moveTo(r * 0.6, r * 0.35);
      ctx.lineTo(r + 2, 1 * jawOpen);
      ctx.lineTo(r * 0.6, 0);
      ctx.closePath();
      ctx.fill();
      // Teeth
      ctx.fillStyle = '#fff';
      for (let t = 0; t < 3; t++) {
        const tx = r * 0.65 + t * 2.5;
        ctx.beginPath(); ctx.moveTo(tx, -1); ctx.lineTo(tx + 1, 0.5); ctx.lineTo(tx + 2, -1); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(tx, 1); ctx.lineTo(tx + 1, -0.5); ctx.lineTo(tx + 2, 1); ctx.closePath(); ctx.fill();
      }
    }

    ctx.restore();
  }

  // ===== Grizzly Bear sprite (Level 3) =====
  function drawBearSprite(px, py, g, inHome) {
    const r = TILE * 0.45;
    const frightened = g.mode === 'frightened';
    const flashing = frightened && g.frightTimer < 80 && Math.floor(state.frameTick / 8) % 2 === 0;

    let angle = 0;
    if (g.eyeDir === DIR.RIGHT) angle = 0;
    else if (g.eyeDir === DIR.DOWN) angle = Math.PI / 2;
    else if (g.eyeDir === DIR.LEFT) angle = Math.PI;
    else if (g.eyeDir === DIR.UP) angle = -Math.PI / 2;

    ctx.save();
    ctx.translate(px, py);
    ctx.rotate(angle);

    let bodyColor, bodyDark;
    if (frightened) {
      bodyColor = flashing ? '#aaddaa' : '#5577ff';
      bodyDark = flashing ? '#77aa77' : '#3355cc';
    } else {
      bodyColor = g.color;
      bodyDark = shadeColor(g.color, -25);
    }

    // Body (big round bear body)
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fill();

    // Ears (round bear ears)
    ctx.fillStyle = bodyColor;
    ctx.beginPath(); ctx.arc(-5, -r + 1, 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(5, -r + 1, 4, 0, Math.PI * 2); ctx.fill();
    // Inner ears
    ctx.fillStyle = frightened ? bodyDark : shadeColor(g.color, 30);
    ctx.beginPath(); ctx.arc(-5, -r + 1, 2.2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(5, -r + 1, 2.2, 0, Math.PI * 2); ctx.fill();

    // Muzzle (lighter snout area)
    ctx.fillStyle = frightened ? bodyColor : shadeColor(g.color, 50);
    ctx.beginPath();
    ctx.ellipse(4, 0, 4, 3.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Nose
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.ellipse(6.5, 0, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    if (frightened) {
      ctx.fillStyle = flashing ? '#333' : '#fff';
      ctx.beginPath();
      ctx.arc(3, -4, 2.5, 0, Math.PI * 2);
      ctx.arc(3, 4, 2.5, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // Bear eyes (small, dark, beady)
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath(); ctx.arc(4, -3.5, 2, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(4, 3.5, 2, 0, Math.PI * 2); ctx.fill();
      // Eye highlights
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(4.5, -4, 0.7, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(4.5, 3, 0.7, 0, Math.PI * 2); ctx.fill();
    }

    // Mouth (angry growl)
    if (!frightened) {
      const growl = Math.sin(state.frameTick * 0.12) > 0.3;
      if (growl) {
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(7, 0, 2, -Math.PI * 0.4, Math.PI * 0.4);
        ctx.stroke();
        // Fangs
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.moveTo(6, -1.5); ctx.lineTo(6.5, -3); ctx.lineTo(7, -1.5); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(6, 1.5); ctx.lineTo(6.5, 3); ctx.lineTo(7, 1.5); ctx.closePath(); ctx.fill();
      }
    }

    // Claws (visible on walking animation)
    if (!frightened) {
      const clawPhase = Math.sin(state.frameTick * 0.15);
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 0.8;
      // Front claws
      ctx.beginPath(); ctx.moveTo(r - 1, -r * 0.6); ctx.lineTo(r + 2 + clawPhase, -r * 0.7); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(r - 1, -r * 0.4); ctx.lineTo(r + 2 + clawPhase, -r * 0.4); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(r - 1, r * 0.6); ctx.lineTo(r + 2 + clawPhase, r * 0.7); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(r - 1, r * 0.4); ctx.lineTo(r + 2 + clawPhase, r * 0.4); ctx.stroke();
    }

    ctx.restore();
  }

  function shadeColor(color, percent) {
    let num = parseInt(color.replace('#', ''), 16);
    let r = Math.min(255, Math.max(0, (num >> 16) + percent));
    let g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + percent));
    let b = Math.min(255, Math.max(0, (num & 0x0000FF) + percent));
    return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
  }

  function drawGhostEyes(px, py, dir) {
    const config = getEnemyConfig();
    ctx.save();
    ctx.translate(px, py);

    let pdx = 0, pdy = 0;
    if (dir === DIR.LEFT) pdx = -1.5;
    if (dir === DIR.RIGHT) pdx = 1.5;
    if (dir === DIR.UP) pdy = -1.5;
    if (dir === DIR.DOWN) pdy = 1.5;

    if (config.type === 'dino') {
      // Dino eyes (white with red iris)
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(-3, -4, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(3, -4, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#cc2200';
      ctx.beginPath(); ctx.arc(-3 + pdx, -4 + pdy, 1.8, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(3 + pdx, -4 + pdy, 1.8, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.arc(-3 + pdx, -4 + pdy, 0.9, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(3 + pdx, -4 + pdy, 0.9, 0, Math.PI * 2); ctx.fill();
    } else if (config.type === 'bear') {
      // Bear eyes (small beady dark eyes)
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath(); ctx.arc(-3, -4, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(3, -4, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(-2.5 + pdx, -4.5 + pdy, 0.8, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(3.5 + pdx, -4.5 + pdy, 0.8, 0, Math.PI * 2); ctx.fill();
    } else {
      // Snake eyes (yellow with slit pupils)
      ctx.fillStyle = '#ffe44d';
      ctx.beginPath(); ctx.arc(-3, -4, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(3, -4, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.ellipse(-3 + pdx, -4 + pdy, 0.8, 2.2, 0, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(3 + pdx, -4 + pdy, 0.8, 2.2, 0, 0, Math.PI * 2); ctx.fill();
    }

    ctx.restore();
  }

  // ===== HUD =====
  function updateHUD() {
    document.getElementById('hud-level').textContent = '„É¨„Éô„É´ ' + state.level;
    document.getElementById('hud-score').textContent = '„Çπ„Ç≥„Ç¢: ' + state.score;
    document.getElementById('hud-lives').textContent = 'üêπ'.repeat(state.lives);
  }

  // ===== Overlay =====
  function showOverlay(title, msg, btnText, showHome) {
    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');
    ov.querySelector('h2').textContent = title;
    ov.querySelector('p').innerHTML = msg;
    document.getElementById('start-btn').textContent = btnText;
    const homeBtn = document.getElementById('home-btn');
    homeBtn.style.display = showHome ? 'inline-block' : 'none';
  }

  function hideOverlay() {
    document.getElementById('overlay').classList.add('hidden');
  }

  // ===== Input =====
  let inputDir = DIR.NONE;
  let touchActive = false;
  let lastTouchX = 0, lastTouchY = 0;
  let lastInputSource = 'keyboard'; // 'keyboard', 'dpad', 'touch'

  function screenToTile(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
      x: (clientX - rect.left) * scaleX / TILE,
      y: (clientY - rect.top) * scaleY / TILE
    };
  }

  function updateDirFromTouch(clientX, clientY) {
    if (!state.running) return;
    const finger = screenToTile(clientX, clientY);
    const c = state.cookie;
    const hx = c.x + (c.dir >= 0 ? DX[c.dir] * c.moveProgress : 0);
    const hy = c.y + (c.dir >= 0 ? DY[c.dir] * c.moveProgress : 0);
    const dx = finger.x - hx;
    const dy = finger.y - hy;

    if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) return;

    if (Math.abs(dx) > Math.abs(dy)) {
      c.nextDir = dx > 0 ? DIR.RIGHT : DIR.LEFT;
    } else {
      c.nextDir = dy > 0 ? DIR.DOWN : DIR.UP;
    }
  }

  document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowUp' || e.key === 'w') { inputDir = DIR.UP; e.preventDefault(); }
    if (e.key === 'ArrowDown' || e.key === 's') { inputDir = DIR.DOWN; e.preventDefault(); }
    if (e.key === 'ArrowLeft' || e.key === 'a') { inputDir = DIR.LEFT; e.preventDefault(); }
    if (e.key === 'ArrowRight' || e.key === 'd') { inputDir = DIR.RIGHT; e.preventDefault(); }

    if (state.running && inputDir !== DIR.NONE) {
      lastInputSource = 'keyboard';
      state.cookie.nextDir = inputDir;
    }
  });

  // D-Pad buttons
  document.querySelectorAll('.dpad-btn').forEach(function(btn) {
    function handlePress(e) {
      e.preventDefault();
      btn.classList.add('active');
      const d = btn.dataset.dir;
      if (d === 'up') inputDir = DIR.UP;
      if (d === 'down') inputDir = DIR.DOWN;
      if (d === 'left') inputDir = DIR.LEFT;
      if (d === 'right') inputDir = DIR.RIGHT;
      if (state.running) {
        lastInputSource = 'dpad';
        state.cookie.nextDir = inputDir;
      }
    }
    function handleRelease(e) {
      e.preventDefault();
      btn.classList.remove('active');
    }
    btn.addEventListener('touchstart', handlePress, { passive: false });
    btn.addEventListener('touchend', handleRelease, { passive: false });
    btn.addEventListener('mousedown', handlePress);
    btn.addEventListener('mouseup', handleRelease);
    btn.addEventListener('mouseleave', handleRelease);
  });

  // Touch controls on canvas - hamster follows finger position
  canvas.addEventListener('touchstart', function(e) {
    touchActive = true;
    lastInputSource = 'touch';
    const t = e.touches[0];
    lastTouchX = t.clientX;
    lastTouchY = t.clientY;
    updateDirFromTouch(t.clientX, t.clientY);
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener('touchmove', function(e) {
    const t = e.touches[0];
    lastTouchX = t.clientX;
    lastTouchY = t.clientY;
    updateDirFromTouch(t.clientX, t.clientY);
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener('touchend', function(e) {
    touchActive = false;
    e.preventDefault();
  }, { passive: false });

  // Start button (handles both game start and level transitions)
  document.getElementById('start-btn').addEventListener('click', function() {
    if (state.level > 1 && !state.gameOver && !state.won && state.lives > 0) {
      // Continue to next level
      initLevel();
      state.running = true;
      updateHUD();
      hideOverlay();
    } else {
      startGame();
    }
  });

  // ===== Game Loop =====
  function gameLoop() {
    if (state.running) {
      state.frameTick++;

      moveCookie();
      moveGhosts();
      checkCollisions();

      // Power mode timer
      if (state.powerMode) {
        state.powerTimer--;
        if (state.powerTimer <= 0) {
          state.powerMode = false;
        }
      }

      updateHUD();
    }

    draw();
    requestAnimationFrame(gameLoop);
  }

  // Initialize level so draw() can render the maze behind the overlay
  initLevel();

  // Start the render loop
  draw();
  requestAnimationFrame(gameLoop);

})();
</script>
</body>
</html>
