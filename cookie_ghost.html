<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Cookie Ghost Whack - „ÇØ„ÉÉ„Ç≠„Éº„Åä„Å∞„Åë„Åü„Åü„Åç</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Nunito', sans-serif;
    background: linear-gradient(135deg, #e8d5f5 0%, #d1c4e9 50%, #b39ddb 100%);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    overflow: hidden;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }

  .game-wrapper {
    width: 100%;
    max-width: 420px;
    background: #fff9f0;
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.15);
    padding: 16px;
    position: relative;
    overflow: hidden;
  }

  .game-wrapper::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 5px;
    background: linear-gradient(90deg, #ab47bc, #ffa726, #66bb6a, #42a5f5);
  }

  .game-header {
    text-align: center;
    margin-bottom: 10px;
  }

  .game-header h1 {
    font-size: 1.4rem;
    font-weight: 900;
    color: #6a1b9a;
  }

  .game-header .sub {
    font-size: 0.7rem;
    color: #ab47bc;
  }

  .hud {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-size: 0.8rem;
    font-weight: 700;
    color: #4e342e;
  }

  .hud-left, .hud-right {
    display: flex;
    gap: 12px;
    align-items: center;
  }

  .hp-bar-container {
    width: 80px;
    height: 12px;
    background: #e0e0e0;
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #bdbdbd;
  }

  .hp-bar {
    height: 100%;
    background: linear-gradient(90deg, #66bb6a, #43a047);
    transition: width 0.3s ease;
    border-radius: 6px;
  }

  .hp-bar.danger {
    background: linear-gradient(90deg, #ef5350, #e53935);
  }

  .hp-bar.warning {
    background: linear-gradient(90deg, #ffa726, #fb8c00);
  }

  canvas {
    display: block;
    width: 100%;
    border-radius: 12px;
    border: 2px solid #ce93d8;
    background: #f3e5f5;
    touch-action: none;
    cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><text y="24" font-size="24">üî®</text></svg>') 16 16, pointer;
  }

  .screen-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.6);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 20px;
    z-index: 10;
  }

  .screen-overlay.hidden { display: none; }

  .screen-box {
    background: #fff9f0;
    border-radius: 20px;
    padding: 32px 28px;
    text-align: center;
    max-width: 320px;
    width: 90%;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
  }

  .screen-box h2 {
    font-size: 1.5rem;
    font-weight: 900;
    color: #6a1b9a;
    margin-bottom: 8px;
  }

  .screen-box p {
    font-size: 0.85rem;
    color: #5d4037;
    margin-bottom: 16px;
    line-height: 1.5;
  }

  .screen-box .emoji-big {
    font-size: 3rem;
    margin-bottom: 12px;
  }

  .btn {
    display: inline-block;
    padding: 12px 32px;
    font-family: 'Nunito', sans-serif;
    font-size: 1rem;
    font-weight: 900;
    color: #fff;
    background: linear-gradient(135deg, #ab47bc, #8e24aa);
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 4px;
  }

  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(156,39,176,0.4);
  }

  .btn:active {
    transform: translateY(0);
  }

  .btn.secondary {
    background: linear-gradient(135deg, #a1887f, #8d6e63);
  }

  .level-info {
    font-size: 0.75rem;
    color: #ab47bc;
    margin-top: 8px;
  }

  .back-link {
    display: block;
    text-align: center;
    margin-top: 10px;
    font-size: 0.75rem;
    color: #ce93d8;
    text-decoration: none;
  }

  .back-link:hover { color: #ab47bc; }

  @media (max-width: 480px) {
    body { padding: 6px; }
    .game-wrapper { padding: 10px; border-radius: 16px; }
    .game-header h1 { font-size: 1.2rem; }
    .hud { font-size: 0.7rem; }
  }
</style>
</head>
<body>
<div class="game-wrapper">
  <div class="game-header">
    <h1>üêπ „ÇØ„ÉÉ„Ç≠„Éº„Åä„Å∞„Åë„Åü„Åü„Åç</h1>
    <div class="sub">Cookie Ghost Whack</div>
  </div>

  <div class="hud">
    <div class="hud-left">
      <span id="levelDisplay">Lv.1</span>
      <span id="scoreDisplay">Score: 0</span>
    </div>
    <div class="hud-right">
      <span>HP</span>
      <div class="hp-bar-container">
        <div class="hp-bar" id="hpBar"></div>
      </div>
    </div>
  </div>

  <canvas id="gameCanvas" width="390" height="480"></canvas>

  <!-- Start Screen -->
  <div class="screen-overlay" id="startScreen">
    <div class="screen-box">
      <div class="emoji-big">üêπüî®üëª</div>
      <h2>„ÇØ„ÉÉ„Ç≠„Éº„Åä„Å∞„Åë„Åü„Åü„Åç</h2>
      <p>Á©¥„Åã„ÇâÂá∫„Å¶„Åè„Çã„Åä„Å∞„Åë„Çí„Åü„Åü„Åì„ÅÜÔºÅ<br>ÁàÜÂºæ„Çí„Åü„Åü„Åè„Å®„ÉÄ„É°„Éº„Ç∏ÔºÅ<br>„É¨„Éô„É´„Åå‰∏ä„Åå„Çã„Å®Á©¥„ÅåÂ¢ó„Åà„Çã„ÇàÔºÅ<br><small style="color:#ab47bc">„Çø„ÉÉ„Éó„Éª„ÇØ„É™„ÉÉ„ÇØ„Åß„Åä„Å∞„Åë„Çí„Åü„Åü„ÅëÔºÅ</small></p>
      <button class="btn" id="startBtn">„Çπ„Çø„Éº„ÉàÔºÅ</button>
      <div class="level-info">„Çø„ÉÉ„Éó or „ÇØ„É™„ÉÉ„ÇØ„ÅßÊìç‰Ωú</div>
    </div>
  </div>

  <!-- Level Clear Screen -->
  <div class="screen-overlay hidden" id="clearScreen">
    <div class="screen-box">
      <div class="emoji-big">üéâ</div>
      <h2>„É¨„Éô„É´„ÇØ„É™„Ç¢ÔºÅ</h2>
      <p id="clearMsg"></p>
      <button class="btn" id="nextLevelBtn">Ê¨°„ÅÆ„É¨„Éô„É´„Å∏</button>
    </div>
  </div>

  <!-- Game Over Screen -->
  <div class="screen-overlay hidden" id="gameOverScreen">
    <div class="screen-box">
      <div class="emoji-big">üòµ</div>
      <h2>„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h2>
      <p id="gameOverMsg"></p>
      <button class="btn" id="retryBtn">„ÇÇ„ÅÜ‰∏ÄÂõû</button>
      <button class="btn secondary" id="homeBtn">„Éõ„Éº„É†„Å∏</button>
    </div>
  </div>

  <!-- Game Complete Screen -->
  <div class="screen-overlay hidden" id="winScreen">
    <div class="screen-box">
      <div class="emoji-big">üèÜüêπ</div>
      <h2>„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅ</h2>
      <p id="winMsg"></p>
      <button class="btn" id="replayBtn">„ÇÇ„ÅÜ‰∏ÄÂõûÈÅä„Å∂</button>
      <button class="btn secondary" id="homeBtn2">„Éõ„Éº„É†„Å∏</button>
    </div>
  </div>

  <a href="index.html" class="back-link">‚Üê „Ç≤„Éº„É†‰∏ÄË¶ß„Å´Êàª„Çã</a>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Responsive canvas sizing
function resizeCanvas() {
  const wrapper = canvas.parentElement;
  const w = wrapper.clientWidth - 24;
  canvas.style.width = w + 'px';
  canvas.style.height = (w * canvas.height / canvas.width) + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const W = canvas.width;
const H = canvas.height;

// Game state
let game = {
  state: 'start',
  level: 1,
  score: 0,
  hp: 100,
  maxHp: 100,
  targetScore: 0,
  holes: [],
  particles: [],
  popups: [],
  frameCount: 0,
  damageFlash: 0,
  comboCount: 0,
  hammerX: W / 2,
  hammerY: H / 2,
  hammerSmash: 0, // animation timer for hammer smash
  hammerAngle: 0,
  timeLeft: 0,
  maxTime: 0,
  spawnTimer: 0,
  bgStars: [],
};

// Initialize background stars
for (let i = 0; i < 30; i++) {
  game.bgStars.push({
    x: Math.random() * W,
    y: Math.random() * H,
    size: Math.random() * 2 + 0.5,
    twinkle: Math.random() * Math.PI * 2
  });
}

// Level configurations
// Each level: more holes, faster spawns, higher target score
const LEVELS = {
  1: {
    name: '„Åä„Å∞„Åë„ÅÆÊ£Æ',
    rows: 2, cols: 2, // 4 holes
    targetScore: 200,
    timeLimit: 45,
    spawnInterval: 90,
    ghostDuration: 80,
    ghostChance: 0.85,
    bombChance: 0.15,
    goldenChance: 0,
  },
  2: {
    name: '„Åä„Å∞„Åë„ÅÆÊ¥ûÁ™ü',
    rows: 2, cols: 3, // 6 holes
    targetScore: 600,
    timeLimit: 50,
    spawnInterval: 70,
    ghostDuration: 70,
    ghostChance: 0.70,
    bombChance: 0.20,
    goldenChance: 0.10,
  },
  3: {
    name: '„Åä„Å∞„Åë„ÅÆÂüé',
    rows: 3, cols: 3, // 9 holes
    targetScore: 1000,
    timeLimit: 55,
    spawnInterval: 55,
    ghostDuration: 60,
    ghostChance: 0.60,
    bombChance: 0.25,
    goldenChance: 0.15,
  },
  4: {
    name: '„Åä„Å∞„Åë„ÅÆÂú∞ÁçÑ',
    rows: 3, cols: 4, // 12 holes
    targetScore: 1500,
    timeLimit: 60,
    spawnInterval: 40,
    ghostDuration: 50,
    ghostChance: 0.55,
    bombChance: 0.30,
    goldenChance: 0.15,
  },
  5: {
    name: '„Åä„Å∞„Åë„ÅÆÁéãÂõΩ',
    rows: 4, cols: 4, // 16 holes
    targetScore: 2200,
    timeLimit: 65,
    spawnInterval: 30,
    ghostDuration: 45,
    ghostChance: 0.50,
    bombChance: 0.30,
    goldenChance: 0.20,
  }
};
const MAX_LEVEL = 5;

// Hole object
function createHoles(rows, cols) {
  const holes = [];
  const marginX = 40;
  const marginTop = 50;
  const marginBottom = 40;
  const areaW = W - marginX * 2;
  const areaH = H - marginTop - marginBottom;
  const spacingX = areaW / cols;
  const spacingY = areaH / rows;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      holes.push({
        x: marginX + spacingX * (c + 0.5),
        y: marginTop + spacingY * (r + 0.5),
        radiusX: Math.min(spacingX, spacingY) * 0.32,
        radiusY: Math.min(spacingX, spacingY) * 0.18,
        // occupant state
        occupant: null, // null, 'ghost', 'bomb', 'golden'
        occupantTimer: 0,
        occupantMaxTimer: 0,
        cooldown: 0,
        whacked: false,
        whackTimer: 0,
      });
    }
  }
  return holes;
}

// Spawn an occupant in a random empty hole
function spawnOccupant() {
  const levelConfig = LEVELS[game.level];
  const emptyHoles = game.holes.filter(h => h.occupant === null && h.cooldown <= 0);
  if (emptyHoles.length === 0) return;

  const hole = emptyHoles[Math.floor(Math.random() * emptyHoles.length)];
  const roll = Math.random();

  if (roll < levelConfig.goldenChance) {
    hole.occupant = 'golden';
  } else if (roll < levelConfig.goldenChance + levelConfig.bombChance) {
    hole.occupant = 'bomb';
  } else {
    hole.occupant = 'ghost';
  }

  const variation = (Math.random() - 0.5) * 20;
  hole.occupantTimer = levelConfig.ghostDuration + variation;
  hole.occupantMaxTimer = hole.occupantTimer;
  hole.whacked = false;
  hole.whackTimer = 0;
}

// Drawing functions

function drawBackground() {
  // Night sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  if (game.level <= 1) {
    grad.addColorStop(0, '#1a0533');
    grad.addColorStop(0.5, '#2d1b69');
    grad.addColorStop(1, '#1b5e20');
  } else if (game.level === 2) {
    grad.addColorStop(0, '#0d0d2b');
    grad.addColorStop(0.5, '#1a1a4e');
    grad.addColorStop(1, '#263238');
  } else if (game.level === 3) {
    grad.addColorStop(0, '#1a0a2e');
    grad.addColorStop(0.5, '#4a148c');
    grad.addColorStop(1, '#311b92');
  } else if (game.level === 4) {
    grad.addColorStop(0, '#1b0000');
    grad.addColorStop(0.5, '#4e0000');
    grad.addColorStop(1, '#2e0033');
  } else {
    grad.addColorStop(0, '#0a0a0a');
    grad.addColorStop(0.5, '#1a0033');
    grad.addColorStop(1, '#000033');
  }
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Twinkling stars
  for (const star of game.bgStars) {
    star.twinkle += 0.03;
    const alpha = 0.3 + Math.sin(star.twinkle) * 0.3;
    ctx.fillStyle = `rgba(255, 255, 200, ${alpha})`;
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
    ctx.fill();
  }

  // Moon
  ctx.fillStyle = '#FFF9C4';
  ctx.beginPath();
  ctx.arc(W - 55, 40, 25, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(W - 45, 35, 22, 0, Math.PI * 2);
  ctx.fill();
  // Moon glow
  ctx.fillStyle = 'rgba(255, 249, 196, 0.08)';
  ctx.beginPath();
  ctx.arc(W - 55, 40, 45, 0, Math.PI * 2);
  ctx.fill();

  // Ground
  ctx.fillStyle = '#2E7D32';
  ctx.fillRect(0, H - 30, W, 30);
  ctx.fillStyle = '#388E3C';
  ctx.fillRect(0, H - 30, W, 5);
  // Grass tufts
  ctx.fillStyle = '#43A047';
  for (let i = 0; i < W; i += 18) {
    ctx.beginPath();
    ctx.moveTo(i, H - 30);
    ctx.lineTo(i + 4, H - 38);
    ctx.lineTo(i + 8, H - 30);
    ctx.fill();
  }

  // Timer bar at top
  if (game.state === 'playing' && game.maxTime > 0) {
    const timerRatio = game.timeLeft / (game.maxTime * 60);
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(10, 8, W - 20, 10);
    const timerColor = timerRatio > 0.3 ? '#66BB6A' : (timerRatio > 0.15 ? '#FFA726' : '#EF5350');
    ctx.fillStyle = timerColor;
    ctx.fillRect(10, 8, (W - 20) * timerRatio, 10);
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(10, 8, W - 20, 10);

    // Time text
    const seconds = Math.ceil(game.timeLeft / 60);
    ctx.font = '700 11px Nunito';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.fillText(seconds + 's', W / 2, 16);
  }
}

function drawHole(hole) {
  const { x, y, radiusX, radiusY } = hole;

  // Shadow behind hole
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(x, y + 5, radiusX + 5, radiusY + 3, 0, 0, Math.PI * 2);
  ctx.fill();

  // Hole (dark ellipse)
  ctx.fillStyle = '#1a0a2e';
  ctx.beginPath();
  ctx.ellipse(x, y, radiusX, radiusY, 0, 0, Math.PI * 2);
  ctx.fill();

  // Hole rim
  ctx.strokeStyle = '#4a2860';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.ellipse(x, y, radiusX + 1, radiusY + 1, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Inner highlight
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(x, y - 2, radiusX - 3, radiusY - 2, 0, Math.PI + 0.3, Math.PI * 2 - 0.3);
  ctx.stroke();

  // Draw occupant
  if (hole.occupant && hole.occupantTimer > 0) {
    // Pop-up animation
    let popProgress;
    const elapsed = hole.occupantMaxTimer - hole.occupantTimer;
    if (elapsed < 10) {
      popProgress = elapsed / 10; // rising
    } else if (hole.occupantTimer < 15) {
      popProgress = hole.occupantTimer / 15; // sinking
    } else {
      popProgress = 1;
    }

    if (hole.whacked) {
      popProgress = hole.whackTimer / 15;
    }

    const riseHeight = radiusY * 3.5 * popProgress;
    const occY = y - riseHeight;

    // Clip to hide below hole
    ctx.save();
    ctx.beginPath();
    ctx.rect(x - radiusX - 10, 0, (radiusX + 10) * 2, y);
    ctx.clip();

    if (hole.whacked) {
      // Whacked animation - dizzy
      drawWhackedOccupant(hole, x, occY);
    } else if (hole.occupant === 'ghost') {
      drawGhost(x, occY, radiusX * 0.7);
    } else if (hole.occupant === 'golden') {
      drawGoldenGhost(x, occY, radiusX * 0.7);
    } else if (hole.occupant === 'bomb') {
      drawBomb(x, occY, radiusX * 0.55);
    }

    ctx.restore();

    // Draw hole rim on top of occupant (for depth illusion)
    ctx.fillStyle = '#1a0a2e';
    ctx.beginPath();
    ctx.ellipse(x, y, radiusX, radiusY * 0.5, 0, 0, Math.PI);
    ctx.fill();
    ctx.strokeStyle = '#4a2860';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(x, y, radiusX + 1, radiusY + 1, 0, -0.1, Math.PI + 0.1);
    ctx.stroke();
  }
}

function drawGhost(x, y, size) {
  const s = size;
  const wobble = Math.sin(game.frameCount * 0.1) * 2;

  // Ghost body
  ctx.fillStyle = '#E8E8F0';
  ctx.beginPath();
  ctx.moveTo(x - s, y + s * 0.5);
  ctx.quadraticCurveTo(x - s, y - s * 1.2, x, y - s * 1.4);
  ctx.quadraticCurveTo(x + s, y - s * 1.2, x + s, y + s * 0.5);
  // Wavy bottom
  ctx.lineTo(x + s, y + s * 0.8 + wobble);
  ctx.quadraticCurveTo(x + s * 0.6, y + s * 0.4 + wobble, x + s * 0.35, y + s * 0.8 + wobble);
  ctx.quadraticCurveTo(x, y + s * 0.4 + wobble, x - s * 0.35, y + s * 0.8 + wobble);
  ctx.quadraticCurveTo(x - s * 0.6, y + s * 0.4 + wobble, x - s, y + s * 0.8 + wobble);
  ctx.closePath();
  ctx.fill();

  // Ghost outline
  ctx.strokeStyle = '#C5C5D0';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Eyes
  ctx.fillStyle = '#1a1a2e';
  ctx.beginPath();
  ctx.ellipse(x - s * 0.3, y - s * 0.4, s * 0.18, s * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + s * 0.3, y - s * 0.4, s * 0.18, s * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();

  // Eye highlights
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(x - s * 0.25, y - s * 0.5, s * 0.08, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + s * 0.35, y - s * 0.5, s * 0.08, 0, Math.PI * 2);
  ctx.fill();

  // Mouth
  ctx.fillStyle = '#1a1a2e';
  ctx.beginPath();
  ctx.ellipse(x, y + s * 0.05, s * 0.15, s * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();
}

function drawGoldenGhost(x, y, size) {
  const s = size;
  const wobble = Math.sin(game.frameCount * 0.15) * 3;
  const glow = Math.sin(game.frameCount * 0.1) * 0.15 + 0.2;

  // Glow effect
  ctx.fillStyle = `rgba(255, 215, 0, ${glow})`;
  ctx.beginPath();
  ctx.arc(x, y - s * 0.3, s * 2, 0, Math.PI * 2);
  ctx.fill();

  // Ghost body
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.moveTo(x - s, y + s * 0.5);
  ctx.quadraticCurveTo(x - s, y - s * 1.2, x, y - s * 1.4);
  ctx.quadraticCurveTo(x + s, y - s * 1.2, x + s, y + s * 0.5);
  ctx.lineTo(x + s, y + s * 0.8 + wobble);
  ctx.quadraticCurveTo(x + s * 0.6, y + s * 0.4 + wobble, x + s * 0.35, y + s * 0.8 + wobble);
  ctx.quadraticCurveTo(x, y + s * 0.4 + wobble, x - s * 0.35, y + s * 0.8 + wobble);
  ctx.quadraticCurveTo(x - s * 0.6, y + s * 0.4 + wobble, x - s, y + s * 0.8 + wobble);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#FFA000';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Sparkle highlight
  ctx.fillStyle = '#FFF8E1';
  ctx.beginPath();
  ctx.ellipse(x - s * 0.3, y - s * 0.9, s * 0.15, s * 0.3, -0.3, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  ctx.fillStyle = '#B71C1C';
  ctx.beginPath();
  ctx.ellipse(x - s * 0.3, y - s * 0.4, s * 0.18, s * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + s * 0.3, y - s * 0.4, s * 0.18, s * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(x - s * 0.25, y - s * 0.5, s * 0.08, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + s * 0.35, y - s * 0.5, s * 0.08, 0, Math.PI * 2);
  ctx.fill();

  // Crown
  ctx.fillStyle = '#FFA000';
  ctx.beginPath();
  ctx.moveTo(x - s * 0.5, y - s * 1.1);
  ctx.lineTo(x - s * 0.4, y - s * 1.6);
  ctx.lineTo(x - s * 0.15, y - s * 1.3);
  ctx.lineTo(x, y - s * 1.7);
  ctx.lineTo(x + s * 0.15, y - s * 1.3);
  ctx.lineTo(x + s * 0.4, y - s * 1.6);
  ctx.lineTo(x + s * 0.5, y - s * 1.1);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#E65100';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Jewels on crown
  ctx.fillStyle = '#E53935';
  ctx.beginPath();
  ctx.arc(x, y - s * 1.35, s * 0.08, 0, Math.PI * 2);
  ctx.fill();
}

function drawBomb(x, y, size) {
  const s = size;
  const sparkle = game.frameCount % 10 < 5;

  // Bomb body
  ctx.fillStyle = '#263238';
  ctx.beginPath();
  ctx.arc(x, y, s, 0, Math.PI * 2);
  ctx.fill();

  // Highlight
  ctx.fillStyle = '#455A64';
  ctx.beginPath();
  ctx.arc(x - s * 0.25, y - s * 0.25, s * 0.35, 0, Math.PI * 2);
  ctx.fill();

  // Fuse
  ctx.strokeStyle = '#8D6E63';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(x + s * 0.5, y - s * 0.7);
  ctx.quadraticCurveTo(x + s * 0.8, y - s * 1.3, x + s * 0.3, y - s * 1.4);
  ctx.stroke();

  // Spark on fuse
  if (sparkle) {
    ctx.fillStyle = '#FF6F00';
    ctx.beginPath();
    ctx.arc(x + s * 0.3, y - s * 1.4, s * 0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#FFEB3B';
    ctx.beginPath();
    ctx.arc(x + s * 0.3, y - s * 1.4, s * 0.1, 0, Math.PI * 2);
    ctx.fill();
  } else {
    ctx.fillStyle = '#FF8F00';
    ctx.beginPath();
    ctx.arc(x + s * 0.3, y - s * 1.4, s * 0.15, 0, Math.PI * 2);
    ctx.fill();
  }

  // Skull symbol
  ctx.fillStyle = '#BDBDBD';
  ctx.beginPath();
  ctx.arc(x, y - s * 0.1, s * 0.35, 0, Math.PI * 2);
  ctx.fill();
  // Skull eyes
  ctx.fillStyle = '#263238';
  ctx.beginPath();
  ctx.arc(x - s * 0.13, y - s * 0.2, s * 0.1, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + s * 0.13, y - s * 0.2, s * 0.1, 0, Math.PI * 2);
  ctx.fill();
  // Skull teeth
  ctx.fillStyle = '#263238';
  ctx.fillRect(x - s * 0.15, y + s * 0.05, s * 0.08, s * 0.1);
  ctx.fillRect(x + s * 0.07, y + s * 0.05, s * 0.08, s * 0.1);
}

function drawWhackedOccupant(hole, x, y) {
  const s = hole.radiusX * 0.5;
  // Dizzy stars
  ctx.font = `${s * 1.2}px serif`;
  ctx.textAlign = 'center';
  const angle1 = game.frameCount * 0.15;
  const angle2 = angle1 + Math.PI;
  ctx.fillText('‚≠ê', x + Math.cos(angle1) * s * 0.8, y - s * 0.8 + Math.sin(angle1) * s * 0.3);
  ctx.fillText('‚≠ê', x + Math.cos(angle2) * s * 0.8, y - s * 0.8 + Math.sin(angle2) * s * 0.3);

  // X eyes ghost
  ctx.fillStyle = hole.occupant === 'golden' ? '#FFD700' : '#C8C8D0';
  ctx.beginPath();
  ctx.arc(x, y, s * 0.9, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  // X eye left
  ctx.beginPath();
  ctx.moveTo(x - s * 0.5, y - s * 0.4);
  ctx.lineTo(x - s * 0.15, y - s * 0.1);
  ctx.moveTo(x - s * 0.15, y - s * 0.4);
  ctx.lineTo(x - s * 0.5, y - s * 0.1);
  ctx.stroke();
  // X eye right
  ctx.beginPath();
  ctx.moveTo(x + s * 0.15, y - s * 0.4);
  ctx.lineTo(x + s * 0.5, y - s * 0.1);
  ctx.moveTo(x + s * 0.5, y - s * 0.4);
  ctx.lineTo(x + s * 0.15, y - s * 0.1);
  ctx.stroke();
}

function drawHammer() {
  if (game.state !== 'playing') return;

  const hx = game.hammerX;
  const hy = game.hammerY;
  const smashAngle = game.hammerSmash > 0 ? -0.5 + game.hammerSmash * 0.15 : -0.3;

  ctx.save();
  ctx.translate(hx, hy);
  ctx.rotate(smashAngle);

  // Handle
  ctx.fillStyle = '#8D6E63';
  ctx.fillRect(-3, -2, 6, 35);
  ctx.strokeStyle = '#6D4C41';
  ctx.lineWidth = 1;
  ctx.strokeRect(-3, -2, 6, 35);
  // Grip lines
  ctx.strokeStyle = '#5D4037';
  ctx.lineWidth = 1;
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.moveTo(-3, 20 + i * 5);
    ctx.lineTo(3, 20 + i * 5);
    ctx.stroke();
  }

  // Hammer head
  ctx.fillStyle = '#78909C';
  ctx.beginPath();
  ctx.roundRect(-14, -18, 28, 20, 3);
  ctx.fill();
  ctx.strokeStyle = '#546E7A';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  // Metallic highlight
  ctx.fillStyle = '#90A4AE';
  ctx.fillRect(-12, -16, 24, 5);
  // Star decoration
  ctx.fillStyle = '#FFD54F';
  ctx.font = '10px serif';
  ctx.textAlign = 'center';
  ctx.fillText('‚òÖ', 0, -4);

  // Impact effect
  if (game.hammerSmash > 3) {
    ctx.fillStyle = `rgba(255, 255, 0, ${(game.hammerSmash - 3) * 0.15})`;
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      const dist = (8 - game.hammerSmash) * 5;
      ctx.beginPath();
      ctx.arc(Math.cos(angle) * dist, -8 + Math.sin(angle) * dist, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();
}

function drawCookieHamster() {
  // Draw small Cookie hamster in corner as mascot
  const cx = 30;
  const cy = H - 45;

  // Body
  ctx.fillStyle = '#FFCC80';
  ctx.beginPath();
  ctx.ellipse(cx, cy + 5, 14, 11, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#E6A23C';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Belly
  ctx.fillStyle = '#FFF8E1';
  ctx.beginPath();
  ctx.ellipse(cx, cy + 8, 8, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // Head
  ctx.fillStyle = '#FFCC80';
  ctx.beginPath();
  ctx.arc(cx, cy - 8, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#E6A23C';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Ears
  ctx.fillStyle = '#FFCC80';
  ctx.beginPath();
  ctx.ellipse(cx - 9, cy - 17, 5, 6, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FFAB91';
  ctx.beginPath();
  ctx.ellipse(cx - 9, cy - 17, 3, 3.5, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FFCC80';
  ctx.beginPath();
  ctx.ellipse(cx + 9, cy - 17, 5, 6, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FFAB91';
  ctx.beginPath();
  ctx.ellipse(cx + 9, cy - 17, 3, 3.5, 0.3, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  ctx.fillStyle = '#3E2723';
  ctx.beginPath();
  ctx.arc(cx - 4, cy - 10, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(cx + 4, cy - 10, 2, 0, Math.PI * 2);
  ctx.fill();
  // Eye highlights
  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(cx - 3.5, cy - 10.5, 0.8, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(cx + 4.5, cy - 10.5, 0.8, 0, Math.PI * 2);
  ctx.fill();

  // Nose
  ctx.fillStyle = '#FF8A80';
  ctx.beginPath();
  ctx.ellipse(cx, cy - 6, 1.8, 1.5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Cheeks
  ctx.fillStyle = 'rgba(255,138,128,0.4)';
  ctx.beginPath();
  ctx.ellipse(cx - 10, cy - 6, 3, 2.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx + 10, cy - 6, 3, 2.5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Speech bubble when combo
  if (game.comboCount >= 3 && game.state === 'playing') {
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(cx + 30, cy - 25, 22, 14, 0, 0, Math.PI * 2);
    ctx.fill();
    // Tail
    ctx.beginPath();
    ctx.moveTo(cx + 15, cy - 18);
    ctx.lineTo(cx + 20, cy - 14);
    ctx.lineTo(cx + 22, cy - 22);
    ctx.fill();

    ctx.font = '700 9px Nunito';
    ctx.fillStyle = '#E65100';
    ctx.textAlign = 'center';
    if (game.comboCount >= 10) {
      ctx.fillText('„Åô„Åî„ÅÑ!', cx + 30, cy - 23);
    } else if (game.comboCount >= 5) {
      ctx.fillText('„ÅÑ„ÅÑ„Å≠!', cx + 30, cy - 23);
    } else {
      ctx.fillText('„Ç≥„É≥„Éú!', cx + 30, cy - 23);
    }
  }
}

function drawParticles() {
  for (const p of game.particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    if (p.type === 'star') {
      ctx.font = `${p.size * 4}px serif`;
      ctx.textAlign = 'center';
      ctx.fillText('‚≠ê', p.x, p.y);
    } else {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
}

function drawPopups() {
  for (const p of game.popups) {
    ctx.globalAlpha = Math.min(1, p.timer / 15);
    ctx.font = '900 18px Nunito';
    ctx.textAlign = 'center';
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillText(p.text, p.x + 1, p.y + 1);
    // Text
    ctx.fillStyle = p.color;
    ctx.fillText(p.text, p.x, p.y);
    ctx.globalAlpha = 1;
  }
}

// Particle system
function spawnParticles(x, y, color, count, type) {
  for (let i = 0; i < count; i++) {
    game.particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8 - 3,
      size: Math.random() * 4 + 2,
      color,
      life: 1,
      type: type || 'circle'
    });
  }
}

function addPopup(x, y, text, color) {
  game.popups.push({ x, y, text, color, timer: 40 });
}

// Hit detection - check if click/tap is on an occupied hole
function hitTest(clickX, clickY) {
  for (const hole of game.holes) {
    if (!hole.occupant || hole.occupantTimer <= 0 || hole.whacked) continue;

    // Check if click is within the visible area of the occupant
    const elapsed = hole.occupantMaxTimer - hole.occupantTimer;
    let popProgress;
    if (elapsed < 10) {
      popProgress = elapsed / 10;
    } else if (hole.occupantTimer < 15) {
      popProgress = hole.occupantTimer / 15;
    } else {
      popProgress = 1;
    }

    const riseHeight = hole.radiusY * 3.5 * popProgress;
    const occY = hole.y - riseHeight;
    const hitRadius = hole.radiusX * 0.9;

    const dx = clickX - hole.x;
    const dy = clickY - occY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < hitRadius) {
      return hole;
    }
  }
  return null;
}

function whackHole(hole) {
  game.hammerSmash = 8;

  if (hole.occupant === 'ghost') {
    // Hit a ghost - score!
    const points = 10;
    game.score += points;
    game.comboCount++;
    const comboText = game.comboCount >= 3 ? ` x${game.comboCount}` : '';
    addPopup(hole.x, hole.y - 20, '+' + points + comboText, '#FFD54F');
    spawnParticles(hole.x, hole.y - 15, '#E8E8F0', 6);
    hole.whacked = true;
    hole.whackTimer = 15;
  } else if (hole.occupant === 'golden') {
    // Hit golden ghost - big score!
    const points = 50;
    game.score += points;
    game.comboCount++;
    addPopup(hole.x, hole.y - 20, '+' + points + '!', '#FFD700');
    spawnParticles(hole.x, hole.y - 15, '#FFD700', 10, 'star');
    spawnParticles(hole.x, hole.y - 15, '#FFA000', 6);
    hole.whacked = true;
    hole.whackTimer = 15;
  } else if (hole.occupant === 'bomb') {
    // Hit a bomb - damage!
    const damage = 20 + game.level * 5;
    game.hp -= damage;
    game.damageFlash = 8;
    game.comboCount = 0;
    addPopup(hole.x, hole.y - 20, '-' + damage, '#E53935');
    spawnParticles(hole.x, hole.y - 15, '#FF6F00', 10);
    spawnParticles(hole.x, hole.y - 15, '#E53935', 6);
    hole.whacked = true;
    hole.whackTimer = 15;

    if (game.hp <= 0) {
      game.hp = 0;
      game.state = 'gameover';
      showGameOverScreen();
    }
  }

  // Check level clear
  const levelConfig = LEVELS[game.level];
  if (game.score >= levelConfig.targetScore && game.state === 'playing') {
    if (game.level >= MAX_LEVEL) {
      game.state = 'win';
      showWinScreen();
    } else {
      game.state = 'clear';
      showClearScreen();
    }
  }
}

// Handle click/tap on canvas
function handleCanvasClick(canvasX, canvasY) {
  if (game.state !== 'playing') return;

  // Convert canvas display coordinates to internal coordinates
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  const x = canvasX * scaleX;
  const y = canvasY * scaleY;

  game.hammerX = x;
  game.hammerY = y;

  const hitHole = hitTest(x, y);
  if (hitHole) {
    whackHole(hitHole);
  } else {
    // Miss - small hammer smash animation
    game.hammerSmash = 4;
    game.comboCount = 0;
  }
}

// Update game
function update() {
  if (game.state !== 'playing') return;

  game.frameCount++;

  // Timer countdown
  game.timeLeft--;
  if (game.timeLeft <= 0) {
    const levelConfig = LEVELS[game.level];
    if (game.score >= levelConfig.targetScore) {
      if (game.level >= MAX_LEVEL) {
        game.state = 'win';
        showWinScreen();
      } else {
        game.state = 'clear';
        showClearScreen();
      }
    } else {
      game.state = 'gameover';
      showGameOverScreen();
    }
    return;
  }

  // Spawn occupants
  game.spawnTimer++;
  const levelConfig = LEVELS[game.level];
  if (game.spawnTimer >= levelConfig.spawnInterval) {
    game.spawnTimer = 0;
    // Can spawn multiple at higher levels
    const spawnCount = game.level >= 4 ? 2 : 1;
    for (let i = 0; i < spawnCount; i++) {
      spawnOccupant();
    }
  }

  // Update holes
  for (const hole of game.holes) {
    if (hole.cooldown > 0) hole.cooldown--;

    if (hole.occupant) {
      if (hole.whacked) {
        hole.whackTimer--;
        if (hole.whackTimer <= 0) {
          hole.occupant = null;
          hole.cooldown = 20;
        }
      } else {
        hole.occupantTimer--;
        if (hole.occupantTimer <= 0) {
          hole.occupant = null;
          hole.cooldown = 15;
        }
      }
    }
  }

  // Update particles
  for (let i = game.particles.length - 1; i >= 0; i--) {
    const p = game.particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2;
    p.life -= 0.03;
    if (p.life <= 0) game.particles.splice(i, 1);
  }

  // Update popups
  for (let i = game.popups.length - 1; i >= 0; i--) {
    game.popups[i].timer--;
    game.popups[i].y -= 1.2;
    if (game.popups[i].timer <= 0) game.popups.splice(i, 1);
  }

  // Hammer smash animation
  if (game.hammerSmash > 0) game.hammerSmash -= 0.5;

  // Damage flash
  if (game.damageFlash > 0) game.damageFlash -= 0.2;

  updateHUD();
}

function updateHUD() {
  document.getElementById('levelDisplay').textContent = 'Lv.' + game.level;
  document.getElementById('scoreDisplay').textContent = 'Score: ' + game.score + ' / ' + LEVELS[game.level].targetScore;
  const hpBar = document.getElementById('hpBar');
  const hpPercent = (game.hp / game.maxHp) * 100;
  hpBar.style.width = hpPercent + '%';
  hpBar.className = 'hp-bar';
  if (hpPercent <= 25) hpBar.classList.add('danger');
  else if (hpPercent <= 50) hpBar.classList.add('warning');
}

// Draw everything
function draw() {
  ctx.clearRect(0, 0, W, H);

  drawBackground();

  // Damage flash overlay
  if (game.damageFlash > 0) {
    ctx.fillStyle = `rgba(255, 0, 0, ${game.damageFlash * 0.05})`;
    ctx.fillRect(0, 0, W, H);
  }

  // Draw holes
  for (const hole of game.holes) {
    drawHole(hole);
  }

  // Hammer
  drawHammer();

  // Cookie mascot
  drawCookieHamster();

  // Particles
  drawParticles();

  // Popups
  drawPopups();

  // Level name
  if (game.state === 'playing') {
    ctx.font = '700 12px Nunito';
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.textAlign = 'center';
    ctx.fillText(LEVELS[game.level].name, W / 2, H - 8);
  }
}

// Game loop
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// Screen management
function hideAllScreens() {
  document.getElementById('startScreen').classList.add('hidden');
  document.getElementById('clearScreen').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('winScreen').classList.add('hidden');
}

function showClearScreen() {
  const screen = document.getElementById('clearScreen');
  screen.classList.remove('hidden');
  document.getElementById('clearMsg').textContent =
    '„É¨„Éô„É´' + game.level + '„ÇØ„É™„Ç¢ÔºÅ„Çπ„Ç≥„Ç¢: ' + game.score;
}

function showGameOverScreen() {
  const screen = document.getElementById('gameOverScreen');
  screen.classList.remove('hidden');
  const reason = game.hp <= 0 ? 'ÁàÜÂºæ„Åß„ÇÑ„Çâ„Çå„ÅüÔºÅ' : 'ÊôÇÈñìÂàá„ÇåÔºÅ';
  document.getElementById('gameOverMsg').textContent =
    reason + '\n„Çπ„Ç≥„Ç¢: ' + game.score + ' („É¨„Éô„É´' + game.level + ')';
}

function showWinScreen() {
  const screen = document.getElementById('winScreen');
  screen.classList.remove('hidden');
  document.getElementById('winMsg').textContent =
    '„Åô„Åπ„Å¶„ÅÆ„É¨„Éô„É´„Çí„ÇØ„É™„Ç¢„Åó„Åü„ÇàÔºÅ\nÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ' + game.score;
}

function startGame() {
  game.state = 'playing';
  game.level = 1;
  game.score = 0;
  game.hp = 100;
  game.particles = [];
  game.popups = [];
  game.frameCount = 0;
  game.damageFlash = 0;
  game.comboCount = 0;
  game.spawnTimer = 0;
  game.hammerSmash = 0;

  const levelConfig = LEVELS[game.level];
  game.holes = createHoles(levelConfig.rows, levelConfig.cols);
  game.timeLeft = levelConfig.timeLimit * 60;
  game.maxTime = levelConfig.timeLimit;

  hideAllScreens();
  updateHUD();
}

function nextLevel() {
  game.level++;
  game.state = 'playing';
  game.particles = [];
  game.popups = [];
  game.spawnTimer = 0;
  game.damageFlash = 0;
  game.comboCount = 0;
  game.hammerSmash = 0;
  // Restore some HP on level clear
  game.hp = Math.min(game.maxHp, game.hp + 15);

  const levelConfig = LEVELS[game.level];
  game.holes = createHoles(levelConfig.rows, levelConfig.cols);
  game.timeLeft = levelConfig.timeLimit * 60;
  game.maxTime = levelConfig.timeLimit;

  hideAllScreens();
  updateHUD();
}

// Track mouse position for hammer (even when not clicking)
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  game.hammerX = (e.clientX - rect.left) * scaleX;
  game.hammerY = (e.clientY - rect.top) * scaleY;
});

// Click handler
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  handleCanvasClick(e.clientX - rect.left, e.clientY - rect.top);
});

// Touch handler
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = touch.clientX - rect.left;
  const y = touch.clientY - rect.top;
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  game.hammerX = x * scaleX;
  game.hammerY = y * scaleY;
  handleCanvasClick(x, y);
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  game.hammerX = (touch.clientX - rect.left) * scaleX;
  game.hammerY = (touch.clientY - rect.top) * scaleY;
});

// Button handlers
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('nextLevelBtn').addEventListener('click', nextLevel);
document.getElementById('retryBtn').addEventListener('click', startGame);
document.getElementById('replayBtn').addEventListener('click', startGame);
document.getElementById('homeBtn').addEventListener('click', () => {
  window.location.href = 'index.html';
});
document.getElementById('homeBtn2').addEventListener('click', () => {
  window.location.href = 'index.html';
});

// Start
updateHUD();
gameLoop();
</script>
</body>
</html>
